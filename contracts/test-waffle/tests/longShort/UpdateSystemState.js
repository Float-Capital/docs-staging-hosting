// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Chai = require("../../bindings/chai/Chai.js");
var Chai$1 = require("chai");
var LetOps = require("../../library/LetOps.js");
var Globals = require("../../library/Globals.js");
var Helpers = require("../../library/Helpers.js");
var Js_math = require("rescript/lib/js/js_math.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var HelperActions = require("../../library/HelperActions.js");
var StakerSmocked = require("../../library/smock/StakerSmocked.js");
var LongShortSmocked = require("../../library/smock/LongShortSmocked.js");
var SyntheticTokenSmocked = require("../../library/smock/SyntheticTokenSmocked.js");
var OracleManagerMockSmocked = require("../../library/smock/OracleManagerMockSmocked.js");

function randomValueChange(tokenAmount) {
  return Globals.div(Globals.mul(tokenAmount, ethers.BigNumber.from(Js_math.random_int(-100, 101))), ethers.BigNumber.from("100"));
}

function testUnit(contracts, param) {
  return Globals.describeUnit("updateSystemState", (function (param) {
                describe("_updateSystemStateInternal", (function () {
                        var marketIndex = Helpers.randomJsInteger(undefined);
                        var match = Helpers.Tuple.make7(Helpers.randomTokenAmount);
                        var oldShortValueAfterYield = match[6];
                        var oldLongValueAfterYield = match[5];
                        var oldShortValue = match[4];
                        var oldLongValue = match[3];
                        var oldShortPrice = match[2];
                        var oldLongPrice = match[1];
                        var oldAssetPrice = match[0];
                        var match$1 = Helpers.Tuple.make2(Helpers.randomTokenAmount);
                        var shortSynthSupply = match$1[1];
                        var longSynthSupply = match$1[0];
                        var valueChangeLong = randomValueChange(oldLongValueAfterYield);
                        var valueChangeShort = randomValueChange(oldShortValueAfterYield);
                        var newAssetPrice = Globals.add(oldAssetPrice, Globals.oneBn);
                        var latestUpdateIndexForMarket = Helpers.randomInteger(undefined);
                        var staker = {
                          contents: undefined
                        };
                        var oracle = {
                          contents: undefined
                        };
                        var longSynth = {
                          contents: undefined
                        };
                        var shortSynth = {
                          contents: undefined
                        };
                        var potentialNewLongPrice = {
                          contents: Globals.zeroBn
                        };
                        var potentialNewShortPrice = {
                          contents: Globals.zeroBn
                        };
                        var setup = function (oldAssetPrice, newAssetPrice, oldLongPrice, oldShortPrice, stakerNextPrice_currentUpdateIndex) {
                          return LetOps.AwaitThen.let_(LongShortSmocked.InternalMock.setup(contracts.contents.longShort), (function (param) {
                                        return LetOps.AwaitThen.let_(LongShortSmocked.InternalMock.setupFunctionForUnitTesting(contracts.contents.longShort, "_updateSystemStateInternal"), (function (param) {
                                                      LongShortSmocked.InternalMock.mock_claimAndDistributeYieldThenRebalanceMarketToReturn(oldLongValueAfterYield, oldShortValueAfterYield);
                                                      LongShortSmocked.InternalMock.mock_batchConfirmOutstandingPendingActionsToReturn(valueChangeLong, valueChangeShort);
                                                      return LetOps.AwaitThen.let_(StakerSmocked.make(undefined), (function (stakerSmocked) {
                                                                    return LetOps.AwaitThen.let_(OracleManagerMockSmocked.make(undefined), (function (oracleSmocked) {
                                                                                  oracleSmocked.updatePrice.returns(newAssetPrice);
                                                                                  oracle.contents = oracleSmocked;
                                                                                  staker.contents = stakerSmocked;
                                                                                  return LetOps.AwaitThen.let_(SyntheticTokenSmocked.make(undefined), (function (longSynthSmocked) {
                                                                                                longSynthSmocked.totalSupply.returns(longSynthSupply);
                                                                                                longSynth.contents = longSynthSmocked;
                                                                                                return LetOps.AwaitThen.let_(SyntheticTokenSmocked.make(undefined), (function (shortSynthSmocked) {
                                                                                                              shortSynthSmocked.totalSupply.returns(shortSynthSupply);
                                                                                                              shortSynth.contents = shortSynthSmocked;
                                                                                                              var longShort = contracts.contents.longShort;
                                                                                                              return LetOps.AwaitThen.let_(longShort._getSyntheticTokenPriceExposed(oldLongValueAfterYield, longSynthSupply), (function (predictedLongPrice) {
                                                                                                                            potentialNewLongPrice.contents = predictedLongPrice;
                                                                                                                            return LetOps.AwaitThen.let_(longShort._getSyntheticTokenPriceExposed(oldShortValueAfterYield, shortSynthSupply), (function (predictedShortPrice) {
                                                                                                                                          potentialNewShortPrice.contents = predictedShortPrice;
                                                                                                                                          return LetOps.AwaitThen.let_(longShort.set_updateSystemStateInternalGlobals(marketIndex, latestUpdateIndexForMarket, oldLongPrice, oldShortPrice, oldAssetPrice, oldLongValue, oldShortValue, oracleSmocked.address, stakerSmocked.address, longSynthSmocked.address, shortSynthSmocked.address, stakerNextPrice_currentUpdateIndex), (function (param) {
                                                                                                                                                        return longShort._updateSystemStateInternalExposed(marketIndex);
                                                                                                                                                      }));
                                                                                                                                        }));
                                                                                                                          }));
                                                                                                            }));
                                                                                              }));
                                                                                }));
                                                                  }));
                                                    }));
                                      }));
                        };
                        var setupWithoutPriceChange = function (param) {
                          return setup(oldAssetPrice, oldAssetPrice, oldLongPrice, oldShortPrice, param);
                        };
                        it("shouldn't call pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations if there is no price update", (function () {
                                return LetOps.Await.let_(setupWithoutPriceChange(Globals.zeroBn), (function (param) {
                                              var checkNoStakerCalls = true;
                                              if (checkNoStakerCalls) {
                                                Chai$1.expect(staker.contents.pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations).to.have.callCount(0);
                                              }
                                              return LetOps.AwaitThen.let_(contracts.contents.longShort.marketUpdateIndex(marketIndex), (function (updateIndex) {
                                                            return LetOps.AwaitThen.let_(contracts.contents.longShort.syntheticToken_priceSnapshot(marketIndex, true, updateIndex), (function (newLongPrice) {
                                                                          return LetOps.AwaitThen.let_(contracts.contents.longShort.syntheticToken_priceSnapshot(marketIndex, false, updateIndex), (function (newShortPrice) {
                                                                                        return LetOps.Await.let_(contracts.contents.longShort.assetPrice(marketIndex), (function (assetPrice) {
                                                                                                      Chai.bnEqual(undefined, oldAssetPrice, assetPrice);
                                                                                                      Chai.bnEqual(undefined, updateIndex, latestUpdateIndexForMarket);
                                                                                                      Chai.bnEqual(undefined, newLongPrice, oldLongPrice);
                                                                                                      Chai.bnEqual(undefined, newShortPrice, oldShortPrice);
                                                                                                      Chai$1.expect(LongShortSmocked.InternalMock._claimAndDistributeYieldThenRebalanceMarketFunction(undefined)).to.have.callCount(0);
                                                                                                      Chai$1.expect(LongShortSmocked.InternalMock._getSyntheticTokenPriceFunction(undefined)).to.have.callCount(0);
                                                                                                      Chai$1.expect(LongShortSmocked.InternalMock._batchConfirmOutstandingPendingActionsFunction(undefined)).to.have.callCount(0);
                                                                                                      Chai$1.expect(longSynth.contents.totalSupply).to.have.callCount(0);
                                                                                                      Chai$1.expect(shortSynth.contents.totalSupply).to.have.callCount(0);
                                                                                                      
                                                                                                    }));
                                                                                      }));
                                                                        }));
                                                          }));
                                            }));
                              }));
                        it("calls for the latest price from the oracle", (function () {
                                return LetOps.Await.let_(setupWithoutPriceChange(Globals.zeroBn), (function (param) {
                                              return OracleManagerMockSmocked.updatePriceCallCheck(oracle.contents);
                                            }));
                              }));
                        describe("There is a price change", (function () {
                                var setupWithPriceChange = function (param) {
                                  return setup(oldAssetPrice, newAssetPrice, oldLongPrice, oldShortPrice, param);
                                };
                                it("it should call the pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations on the staker function if there is a price change", (function () {
                                        return LetOps.Await.let_(setupWithPriceChange(Globals.zeroBn), (function (param) {
                                                      return StakerSmocked.pushUpdatedMarketPricesToUpdateFloatIssuanceCalculationsCallCheck(staker.contents, {
                                                                  marketIndex: marketIndex,
                                                                  marketUpdateIndex: Globals.add(latestUpdateIndexForMarket, Globals.oneBn),
                                                                  longPrice: potentialNewLongPrice.contents,
                                                                  shortPrice: potentialNewShortPrice.contents,
                                                                  longValue: Globals.add(oldLongValueAfterYield, valueChangeLong),
                                                                  shortValue: Globals.add(oldShortValueAfterYield, valueChangeShort)
                                                                });
                                                    }));
                                      }));
                                it("it should call `_claimAndDistributeYieldThenRebalanceMarket` with correct arguments", (function () {
                                        return LetOps.Await.let_(setupWithPriceChange(Globals.zeroBn), (function (param) {
                                                      return LongShortSmocked.InternalMock._claimAndDistributeYieldThenRebalanceMarketCallCheck({
                                                                  marketIndex: marketIndex,
                                                                  newAssetPrice: newAssetPrice
                                                                });
                                                    }));
                                      }));
                                it("it should call `_performOutstandingSettlements` with correct arguments", (function () {
                                        return LetOps.Await.let_(setupWithPriceChange(Globals.zeroBn), (function (param) {
                                                      return LongShortSmocked.InternalMock._batchConfirmOutstandingPendingActionsCallCheck({
                                                                  marketIndex: marketIndex,
                                                                  syntheticTokenPrice_inPaymentTokens_long: potentialNewLongPrice.contents,
                                                                  syntheticTokenPrice_inPaymentTokens_short: potentialNewShortPrice.contents
                                                                });
                                                    }));
                                      }));
                                it("should call `totalSupply` on the long and short synth tokens", (function () {
                                        return LetOps.Await.let_(setupWithPriceChange(Globals.zeroBn), (function (param) {
                                                      SyntheticTokenSmocked.totalSupplyCallCheck(longSynth.contents);
                                                      return SyntheticTokenSmocked.totalSupplyCallCheck(shortSynth.contents);
                                                    }));
                                      }));
                                it("should mutate syntheticToken_priceSnapshots for long and short correctly", (function () {
                                        return LetOps.Await.let_(setupWithPriceChange(Globals.zeroBn), (function (param) {
                                                      var newUpdateIndex = Globals.add(latestUpdateIndexForMarket, Globals.oneBn);
                                                      return LetOps.AwaitThen.let_(contracts.contents.longShort.syntheticToken_priceSnapshot(marketIndex, true, newUpdateIndex), (function (newLongPrice) {
                                                                    return LetOps.Await.let_(contracts.contents.longShort.syntheticToken_priceSnapshot(marketIndex, false, newUpdateIndex), (function (newShortPrice) {
                                                                                  Chai.bnEqual(undefined, newLongPrice, potentialNewLongPrice.contents);
                                                                                  return Chai.bnEqual(undefined, newShortPrice, potentialNewShortPrice.contents);
                                                                                }));
                                                                  }));
                                                    }));
                                      }));
                                it("should mutate marketSideValueInPaymentTokens for long and short correctly", (function () {
                                        return LetOps.AwaitThen.let_(setupWithPriceChange(Globals.zeroBn), (function (param) {
                                                      return LetOps.AwaitThen.let_(contracts.contents.longShort.marketSideValueInPaymentToken(marketIndex, true), (function (newLongValue) {
                                                                    return LetOps.Await.let_(contracts.contents.longShort.marketSideValueInPaymentToken(marketIndex, false), (function (newShortValue) {
                                                                                  Chai.bnEqual(undefined, newLongValue, Globals.add(oldLongValueAfterYield, valueChangeLong));
                                                                                  return Chai.bnEqual(undefined, newShortValue, Globals.add(oldShortValueAfterYield, valueChangeShort));
                                                                                }));
                                                                  }));
                                                    }));
                                      }));
                                it("it should update the (underlying) asset price correctly", (function () {
                                        return LetOps.AwaitThen.let_(setupWithPriceChange(Globals.zeroBn), (function (param) {
                                                      return LetOps.Await.let_(contracts.contents.longShort.assetPrice(marketIndex), (function (assetPrice) {
                                                                    return Chai.bnEqual(undefined, assetPrice, newAssetPrice);
                                                                  }));
                                                    }));
                                      }));
                                it("it should increment the marketUpdateIndex by 1", (function () {
                                        return LetOps.AwaitThen.let_(setupWithPriceChange(Globals.zeroBn), (function (param) {
                                                      return LetOps.Await.let_(contracts.contents.longShort.marketUpdateIndex(marketIndex), (function (updateIndex) {
                                                                    return Chai.bnEqual(undefined, Globals.add(latestUpdateIndexForMarket, Globals.oneBn), updateIndex);
                                                                  }));
                                                    }));
                                      }));
                                it("it should emit the SystemStateUpdated event with the correct arguments", (function () {
                                        return Chai.callEmitEvents(setupWithPriceChange(Globals.zeroBn), contracts.contents.longShort, "SystemStateUpdated").withArgs(marketIndex, Globals.add(latestUpdateIndexForMarket, Globals.oneBn), newAssetPrice, Globals.add(oldLongValueAfterYield, valueChangeLong), Globals.add(oldShortValueAfterYield, valueChangeShort), potentialNewLongPrice.contents, potentialNewShortPrice.contents);
                                      }));
                                
                              }));
                        
                      }));
                var setupWithUpdateSystemStateInternalMocked = function (functionName) {
                  return LetOps.AwaitThen.let_(LongShortSmocked.InternalMock.setup(contracts.contents.longShort), (function (param) {
                                return LongShortSmocked.InternalMock.setupFunctionForUnitTesting(contracts.contents.longShort, functionName);
                              }));
                };
                describe("updateSystemStateMulti", (function () {
                        it("should call `_updateSystemStateInternal` for each market in the array", (function () {
                                var marketIndexes = Belt_Array.makeBy(Js_math.random_int(0, 51), (function (param) {
                                        return Helpers.randomJsInteger(undefined);
                                      }));
                                return LetOps.AwaitThen.let_(setupWithUpdateSystemStateInternalMocked("updateSystemStateMulti"), (function (param) {
                                              return LetOps.AwaitThen.let_(contracts.contents.longShort.setMarketExistsMulti(marketIndexes), (function (param) {
                                                            return LetOps.Await.let_(contracts.contents.longShort.updateSystemStateMulti(marketIndexes), (function (param) {
                                                                          return Belt_Array.map(marketIndexes, (function (index) {
                                                                                        return LongShortSmocked.InternalMock._updateSystemStateInternalCallCheck({
                                                                                                    marketIndex: index
                                                                                                  });
                                                                                      }));
                                                                        }));
                                                          }));
                                            }));
                              }));
                        
                      }));
                describe("updateSystemState", (function () {
                        it("should call to `_updateSystemStateInternal` with the correct market as an argument", (function () {
                                var marketIndex = Helpers.randomJsInteger(undefined);
                                return LetOps.AwaitThen.let_(setupWithUpdateSystemStateInternalMocked("updateSystemState"), (function (param) {
                                              return LetOps.AwaitThen.let_(contracts.contents.longShort.setMarketExistsMulti([marketIndex]), (function (param) {
                                                            return LetOps.Await.let_(contracts.contents.longShort.updateSystemState(marketIndex), (function (param) {
                                                                          return LongShortSmocked.InternalMock._updateSystemStateInternalCallCheck({
                                                                                      marketIndex: marketIndex
                                                                                    });
                                                                        }));
                                                          }));
                                            }));
                              }));
                        
                      }));
                
              }));
}

function testIntegration(contracts, accounts) {
  describe("updateSystemState", (function () {
          var testDistributeYield = function (longIsOverBalanced) {
            it("distribute yield to markets flow " + (
                  longIsOverBalanced ? "(long over balanced)" : "(short over balanced)"
                ), (function () {
                    var match = contracts.contents;
                    var longShort = match.longShort;
                    var match$1 = match.markets[0];
                    var marketIndex = match$1.marketIndex;
                    var yieldManager = match$1.yieldManager;
                    var oracleManager = match$1.oracleManager;
                    var paymentToken = match$1.paymentToken;
                    var testUser = accounts.contents[2];
                    var amountOfYieldToAward = Globals.bnFromString("3216543216543216542");
                    return LetOps.Await.let_(longShort.marketSideValueInPaymentToken(marketIndex, !longIsOverBalanced), (function (amountToMintToGuaranteeImbalance) {
                                  return LetOps.AwaitThen.let_(HelperActions.mintDirect(marketIndex, amountToMintToGuaranteeImbalance, paymentToken, testUser, longShort, oracleManager, longIsOverBalanced), (function (param) {
                                                return LetOps.Await.let_(longShort.marketSideValueInPaymentToken(marketIndex, true), (function (longTokenPoolValueBefore) {
                                                              return LetOps.Await.let_(longShort.marketSideValueInPaymentToken(marketIndex, false), (function (shortTokenPoolValueBefore) {
                                                                            return LetOps.Await.let_(yieldManager.totalReservedForTreasury(), (function (totalDueForTreasuryBefore) {
                                                                                          var totalValueRelatedToMarketBefore = Globals.add(Globals.add(longTokenPoolValueBefore, shortTokenPoolValueBefore), totalDueForTreasuryBefore);
                                                                                          yieldManager.settleWithYieldAbsolute(amountOfYieldToAward);
                                                                                          return LetOps.Await.let_(oracleManager.getLatestPrice(), (function (currentOraclePrice) {
                                                                                                        return LetOps.Await.let_(oracleManager.setPrice(Globals.add(currentOraclePrice, Globals.bnFromInt(1))), (function (param) {
                                                                                                                      return LetOps.Await.let_(longShort.updateSystemState(marketIndex), (function (param) {
                                                                                                                                    return LetOps.Await.let_(longShort.marketSideValueInPaymentToken(marketIndex, true), (function (longTokenPoolValueAfter) {
                                                                                                                                                  return LetOps.Await.let_(longShort.marketSideValueInPaymentToken(marketIndex, false), (function (shortTokenPoolValueAfter) {
                                                                                                                                                                return LetOps.Await.let_(yieldManager.totalReservedForTreasury(), (function (totalDueForTreasuryAfter) {
                                                                                                                                                                              var totalValueRelatedToMarketAfter = Globals.add(Globals.add(longTokenPoolValueAfter, shortTokenPoolValueAfter), totalDueForTreasuryAfter);
                                                                                                                                                                              return Chai.bnEqual("yield is either being lost or over-allocated - should be exactly the same", Globals.add(totalValueRelatedToMarketBefore, amountOfYieldToAward), totalValueRelatedToMarketAfter);
                                                                                                                                                                            }));
                                                                                                                                                              }));
                                                                                                                                                }));
                                                                                                                                  }));
                                                                                                                    }));
                                                                                                      }));
                                                                                        }));
                                                                          }));
                                                            }));
                                              }));
                                }));
                  }));
            
          };
          testDistributeYield(true);
          testDistributeYield(false);
          it("cannot call updateSystemState on a market that doesn't exist", (function () {
                  return Chai.expectRevert(contracts.contents.longShort.updateSystemState(321321654), "market doesn't exist");
                }));
          
        }));
  
}

exports.randomValueChange = randomValueChange;
exports.testUnit = testUnit;
exports.testIntegration = testIntegration;
/* Chai Not a pure module */
