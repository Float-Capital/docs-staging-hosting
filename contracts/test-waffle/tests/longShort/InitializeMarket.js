// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Chai = require("../../bindings/chai/Chai.js");
var LetOps = require("../../library/LetOps.js");
var Globals = require("../../library/Globals.js");
var Helpers = require("../../library/Helpers.js");
var CONSTANTS = require("../../CONSTANTS.js");
var StakerSmocked = require("../../library/smock/StakerSmocked.js");
var LongShortSmocked = require("../../library/smock/LongShortSmocked.js");
var LendingPoolAddressesProviderMockSmocked = require("../../library/smock/LendingPoolAddressesProviderMockSmocked.js");

function testUnit(contracts, accounts) {
  describe("initializeMarket", (function () {
          var stakerSmockedRef = {
            contents: undefined
          };
          var longShortRef = {
            contents: ""
          };
          var sampleAddress = ethers.Wallet.createRandom().address;
          var setup = function (marketIndex, marketIndexValue, latestMarket) {
            var match = contracts.contents;
            longShortRef.contents = match.longShort;
            return LetOps.Await.let_(StakerSmocked.make(undefined), (function (smocked) {
                          stakerSmockedRef.contents = smocked;
                          return LetOps.Await.let_(LongShortSmocked.InternalMock.setup(longShortRef.contents), (function (param) {
                                        return LetOps.Await.let_(LongShortSmocked.InternalMock.setupFunctionForUnitTesting(longShortRef.contents, "initializeMarket"), (function (param) {
                                                      return longShortRef.contents.setInitializeMarketParams(marketIndex, marketIndexValue, latestMarket, stakerSmockedRef.contents.address, sampleAddress, sampleAddress);
                                                    }));
                                      }));
                        }));
          };
          it("calls all functions (staker.addNewStakingFund, adminOnly, seedMarketInitially) and mutates state (marketExists) correctly", (function () {
                  return LetOps.Await.let_(setup(1, false, 1), (function (param) {
                                return LetOps.Await.let_(longShortRef.contents.connect(accounts.contents[0]).initializeMarket(1, ethers.BigNumber.from("60000000000000000"), ethers.BigNumber.from("4"), ethers.BigNumber.from("5000000000000000"), CONSTANTS.tenToThe18, Globals.bnFromInt(5), Globals.bnFromInt(0), Globals.bnFromInt(1)), (function (param) {
                                              StakerSmocked.addNewStakingFundCallCheck(stakerSmockedRef.contents, {
                                                    marketIndex: 1,
                                                    longToken: sampleAddress,
                                                    shortToken: sampleAddress,
                                                    kInitialMultiplier: ethers.BigNumber.from("60000000000000000"),
                                                    kPeriod: ethers.BigNumber.from("4"),
                                                    unstakeFee_e18: ethers.BigNumber.from("5000000000000000"),
                                                    balanceIncentiveCurve_exponent: Globals.bnFromInt(5),
                                                    balanceIncentiveCurve_equilibriumOffset: Globals.bnFromInt(0)
                                                  });
                                              return LetOps.Await.let_(longShortRef.contents.marketExists(1), (function (isMarket) {
                                                            Chai.boolEqual(undefined, isMarket, true);
                                                            return LongShortSmocked.InternalMock._seedMarketInitiallyCallCheck({
                                                                        initialMarketSeedForEachMarketSide: CONSTANTS.tenToThe18,
                                                                        marketIndex: 1
                                                                      });
                                                          }));
                                            }));
                              }));
                }));
          it("reverts if market exists", (function () {
                  return LetOps.Await.let_(setup(1, true, 1), (function (param) {
                                return LetOps.Await.let_(Chai.expectRevertNoReason(longShortRef.contents.connect(accounts.contents[0]).initializeMarket(1, ethers.BigNumber.from("60000000000000000"), ethers.BigNumber.from("4"), ethers.BigNumber.from("5000000000000000"), CONSTANTS.tenToThe18, Globals.bnFromInt(5), Globals.bnFromInt(0), Globals.bnFromInt(1))), (function (param) {
                                              
                                            }));
                              }));
                }));
          it("reverts if market index is greater than latest market index", (function () {
                  return LetOps.Await.let_(setup(1, false, 1), (function (param) {
                                return LetOps.Await.let_(Chai.expectRevertNoReason(longShortRef.contents.connect(accounts.contents[0]).initializeMarket(2, ethers.BigNumber.from("60000000000000000"), ethers.BigNumber.from("4"), ethers.BigNumber.from("5000000000000000"), CONSTANTS.tenToThe18, Globals.bnFromInt(5), Globals.bnFromInt(0), Globals.bnFromInt(1))), (function (param) {
                                              
                                            }));
                              }));
                }));
          
        }));
  
}

function testIntegration(contracts, param) {
  describe("initializeMarket", (function () {
          it("Shouldn't allow initialization of a market that doesn't exist", (function () {
                  return Chai.expectRevert(contracts.contents.longShort.initializeMarket(654654, CONSTANTS.oneBn, CONSTANTS.oneBn, ethers.BigNumber.from("5000000000000000"), CONSTANTS.tenToThe18, Globals.bnFromInt(5), Globals.bnFromInt(0), Globals.bnFromInt(1)), "index too high");
                }));
          it("Shouldn't allow initialization of a market that has already been initialized", (function () {
                  var match = contracts.contents;
                  var match$1 = match.markets[0];
                  return Chai.expectRevert(match.longShort.initializeMarket(match$1.marketIndex, CONSTANTS.oneBn, CONSTANTS.oneBn, ethers.BigNumber.from("5000000000000000"), CONSTANTS.tenToThe18, Globals.bnFromInt(5), Globals.bnFromInt(0), Globals.bnFromInt(1)), "already initialized");
                }));
          it("Shouldn't allow initialization with less than 1 eth units of payment token", (function () {
                  var match = contracts.contents;
                  var longShort = match.longShort;
                  var match$1 = match.markets[0];
                  var oracleManager = match$1.oracleManager;
                  var paymentToken = match$1.paymentToken;
                  return LetOps.Await.let_(LendingPoolAddressesProviderMockSmocked.make(undefined), (function (lendingPoolAddressesProviderSmocked) {
                                lendingPoolAddressesProviderSmocked.getLendingPool.returns(Helpers.randomAddress(undefined));
                                return LetOps.Await.let_(Helpers.deployAYieldManager(longShort.address, lendingPoolAddressesProviderSmocked.address), (function (newYieldManager) {
                                              return LetOps.Await.let_(longShort.createNewSyntheticMarket("Test", "T", paymentToken.address, oracleManager.address, newYieldManager.address), (function (param) {
                                                            return LetOps.Await.let_(longShort.latestMarket(), (function (latestMarket) {
                                                                          return Chai.expectRevert(longShort.initializeMarket(latestMarket, CONSTANTS.tenToThe18, CONSTANTS.oneBn, ethers.BigNumber.from("5000000000000000"), CONSTANTS.oneBn, Globals.bnFromInt(5), Globals.bnFromInt(0), Globals.bnFromInt(1)), "Insufficient market seed");
                                                                        }));
                                                          }));
                                            }));
                              }));
                }));
          it("Shouldn't allow creation of a market with the a yield manager already in use", (function () {
                  var match = contracts.contents;
                  var match$1 = match.markets[0];
                  return Chai.expectRevert(match.longShort.createNewSyntheticMarket("Test", "T", match$1.paymentToken.address, match$1.oracleManager.address, match$1.yieldManager.address), "Yield Manager is already in use");
                }));
          
        }));
  
}

exports.testUnit = testUnit;
exports.testIntegration = testIntegration;
/* Chai Not a pure module */
