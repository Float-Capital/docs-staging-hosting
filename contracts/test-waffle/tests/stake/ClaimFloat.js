// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Chai = require("../../bindings/chai/Chai.js");
var LetOps = require("../../library/LetOps.js");
var Globals = require("../../library/Globals.js");
var Helpers = require("../../library/Helpers.js");
var CONSTANTS = require("../../CONSTANTS.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_int32 = require("rescript/lib/js/caml_int32.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var StakerHelpers = require("./StakerHelpers.js");
var StakerSmocked = require("../../library/smock/StakerSmocked.js");

function makeIterator(anyArray) {
  var indexRef = {
    contents: 0
  };
  return function (param) {
    var index = indexRef.contents;
    indexRef.contents = Caml_int32.mod_(index + 1 | 0, anyArray.length);
    return Belt_Array.getExn(anyArray, index);
  };
}

var smockedCalcAccumIterativeBinding = ((_r, arr) => _r.smocked.calculateAccumulatedFloatMock.will.return.with(makeIterator(arr)));

function iterativeMockCalculateAccumulatedFloatToReturn(arr) {
  StakerSmocked.InternalMock.checkForExceptions("calculateAccumulatedFloatHelper");
  Belt_Option.map(StakerSmocked.InternalMock.internalRef.contents, (function (_r) {
          return smockedCalcAccumIterativeBinding(_r, arr);
        }));
  
}

function test(contracts, accounts) {
  describe("_claimFloat", (function () {
          var stakerRef = {
            contents: undefined
          };
          var marketIndices = [
            Helpers.randomJsInteger(undefined),
            Helpers.randomJsInteger(undefined)
          ];
          var latestRewardIndices = [
            Helpers.randomInteger(undefined),
            Helpers.randomInteger(undefined)
          ];
          var floatRewardsForMarkets = [
            Helpers.Tuple.make2(Helpers.randomTokenAmount),
            Helpers.Tuple.make2(function (param) {
                  return CONSTANTS.zeroBn;
                })
          ];
          var sumFloatRewards = function (floatRewards) {
            return Belt_Array.reduce(floatRewards, CONSTANTS.zeroBn, (function (prev, curr) {
                          return prev.add(curr[0]).add(curr[1]);
                        }));
          };
          var userWalletRef = {
            contents: undefined
          };
          var promiseRef = {
            contents: undefined
          };
          var setup = function (marketIndices, latestRewardIndices, floatRewardsForMarkets) {
            return LetOps.AwaitThen.let_(StakerHelpers.deployAndSetupStakerToUnitTest(stakerRef, "_claimFloat", contracts, accounts), (function (param) {
                          userWalletRef.contents = accounts.contents[5];
                          iterativeMockCalculateAccumulatedFloatToReturn(floatRewardsForMarkets);
                          StakerSmocked.InternalMock.mock_mintFloatToReturn(undefined);
                          var setupPromise = Belt_Array.reduceWithIndex(marketIndices, Promise.resolve(undefined), (function (lastPromise, marketIndex, arrayIndex) {
                                  return LetOps.AwaitThen.let_(lastPromise, (function (param) {
                                                return stakerRef.contents.setMintAccumulatedFloatAndClaimFloatParams(marketIndex, latestRewardIndices[arrayIndex]);
                                              }));
                                }));
                          return LetOps.AwaitThen.let_(setupPromise, (function (param) {
                                        promiseRef.contents = stakerRef.contents.connect(userWalletRef.contents)._claimFloatExternal(marketIndices);
                                        return LetOps.Await.let_(promiseRef.contents, (function (param) {
                                                      return promiseRef.contents;
                                                    }));
                                      }));
                        }));
          };
          describe("case at least one market has float to be minted", (function () {
                  Globals.before_once$p(function (param) {
                        return setup(marketIndices, latestRewardIndices, floatRewardsForMarkets);
                      });
                  it("calls mint float for user with correct arguments", (function () {
                          return Chai.recordEqualFlat(Belt_Array.getExn(StakerSmocked.InternalMock._mintFloatCalls(undefined), 0), {
                                      user: userWalletRef.contents.address,
                                      floatToMint: sumFloatRewards(floatRewardsForMarkets)
                                    });
                        }));
                  describe("case market has float to mint", (function () {
                          it("calls calculateAccumulatedFloat with correct arguments", (function () {
                                  return Chai.recordEqualFlat(Belt_Array.getExn(StakerSmocked.InternalMock.calculateAccumulatedFloatCalls(undefined), 0), {
                                              marketIndex: marketIndices[0],
                                              user: userWalletRef.contents.address
                                            });
                                }));
                          it("emits FloatMinted event", (function () {
                                  var match = floatRewardsForMarkets[0];
                                  return LetOps.Await.let_(Chai.callEmitEvents(promiseRef.contents, stakerRef.contents, "FloatMinted").withArgs(userWalletRef.contents.address, Belt_Array.getExn(marketIndices, 0), match[0], match[1], Belt_Array.getExn(latestRewardIndices, 0)), (function (param) {
                                                
                                              }));
                                }));
                          it("mutates userIndexOfLastClaimedReward", (function () {
                                  return LetOps.Await.let_(stakerRef.contents.userIndexOfLastClaimedReward(marketIndices[0], userWalletRef.contents.address), (function (lastClaimed) {
                                                return Chai.bnEqual(undefined, lastClaimed, latestRewardIndices[0]);
                                              }));
                                }));
                          
                        }));
                  describe("case market has no float to mint", (function () {
                          it("doesn't mutate userIndexOfLastClaimed", (function () {
                                  return LetOps.Await.let_(stakerRef.contents.userIndexOfLastClaimedReward(marketIndices[1], userWalletRef.contents.address), (function (lastClaimed) {
                                                return Chai.bnEqual(undefined, lastClaimed, CONSTANTS.zeroBn);
                                              }));
                                }));
                          it("doesn't emit FloatMinted event", (function () {
                                  return Chai.expectToNotEmit(Chai.callEmitEvents(promiseRef.contents, stakerRef.contents, "FloatMinted").withArgs(userWalletRef.contents.address, Belt_Array.getExn(marketIndices, 1), CONSTANTS.zeroBn, CONSTANTS.zeroBn, Belt_Array.getExn(latestRewardIndices, 1)));
                                }));
                          
                        }));
                  
                }));
          describe("case no market has float to be minted", (function () {
                  Globals.before_once$p(function (param) {
                        var zero2Tuple = [
                          CONSTANTS.zeroBn,
                          CONSTANTS.zeroBn
                        ];
                        return setup(marketIndices, latestRewardIndices, [
                                    zero2Tuple,
                                    zero2Tuple
                                  ]);
                      });
                  it("doesn't mint float", (function () {
                          return Chai.intEqual(undefined, StakerSmocked.InternalMock._mintFloatCalls(undefined).length, 0);
                        }));
                  
                }));
          
        }));
  
}

exports.makeIterator = makeIterator;
exports.smockedCalcAccumIterativeBinding = smockedCalcAccumIterativeBinding;
exports.iterativeMockCalculateAccumulatedFloatToReturn = iterativeMockCalculateAccumulatedFloatToReturn;
exports.test = test;
/* Chai Not a pure module */
