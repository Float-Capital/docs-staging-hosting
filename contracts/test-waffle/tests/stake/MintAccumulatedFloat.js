// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Chai = require("../../bindings/chai/Chai.js");
var Chai$1 = require("chai");
var LetOps = require("../../library/LetOps.js");
var Globals = require("../../library/Globals.js");
var Helpers = require("../../library/Helpers.js");
var CONSTANTS = require("../../CONSTANTS.js");
var StakerSmocked = require("../../library/smock/StakerSmocked.js");
var StakerStakeSetters = require("../../library/StakerStakeSetters.js");

function test(contracts, param) {
  describe("mintAccumulatedFloat", (function () {
          var marketIndex = Helpers.randomJsInteger(undefined);
          var match = Helpers.Tuple.make3(Helpers.randomTokenAmount);
          var latestRewardIndexForMarket = match[2];
          var floatToMintShort = match[1];
          var floatToMintLong = match[0];
          var user = Helpers.randomAddress(undefined);
          var promiseRef = {
            contents: undefined
          };
          var setup = function (floatToMintLong, floatToMintShort) {
            var match = contracts.contents;
            var staker = match.staker;
            return LetOps.AwaitThen.let_(StakerSmocked.InternalMock.setupFunctionForUnitTesting(staker, "mintAccumulatedFloat"), (function (param) {
                          StakerSmocked.InternalMock.mock_calculateAccumulatedFloatAndExecuteOutstandingShiftsToReturn(Globals.add(floatToMintLong, floatToMintShort));
                          return LetOps.AwaitThen.let_(staker.setMintAccumulatedFloatAndClaimFloatParams(marketIndex, latestRewardIndexForMarket), (function (param) {
                                        promiseRef.contents = contracts.contents.staker._mintAccumulatedFloatAndExecuteOutstandingShiftsExposed(marketIndex, user);
                                        return LetOps.Await.let_(promiseRef.contents, (function (param) {
                                                      return promiseRef.contents;
                                                    }));
                                      }));
                        }));
          };
          describe("case floatToMint > 0", (function () {
                  Globals.before_once$p(function (param) {
                        return setup(floatToMintLong, floatToMintShort);
                      });
                  it("calls calculateAccumulatedFloat with correct arguments", (function () {
                          return StakerSmocked.InternalMock._calculateAccumulatedFloatAndExecuteOutstandingShiftsCallCheck({
                                      marketIndex: marketIndex,
                                      user: user
                                    });
                        }));
                  it("calls mintFloat with correct arguments", (function () {
                          return StakerSmocked.InternalMock._mintFloatCallCheck({
                                      user: user,
                                      floatToMint: floatToMintLong.add(floatToMintShort)
                                    });
                        }));
                  it("emits FloatMinted event", (function () {
                          return Chai.callEmitEvents(promiseRef.contents, contracts.contents.staker, "FloatMinted").withArgs(user, marketIndex, Globals.add(floatToMintLong, floatToMintShort));
                        }));
                  it("mutates userIndexOfLastClaimedReward", (function () {
                          return LetOps.Await.let_(contracts.contents.staker.userIndexOfLastClaimedReward(marketIndex, user), (function (lastClaimed) {
                                        return Chai.bnEqual(undefined, lastClaimed, latestRewardIndexForMarket);
                                      }));
                        }));
                  
                }));
          describe("case floatToMint == 0", (function () {
                  Globals.before_once$p(function (param) {
                        var match = contracts.contents;
                        return LetOps.Await.let_(StakerStakeSetters.setUserIndexOfLastClaimedReward(match.staker, marketIndex, user, Globals.zeroBn), (function (param) {
                                      return setup(CONSTANTS.zeroBn, CONSTANTS.zeroBn);
                                    }));
                      });
                  it("calls calculateAccumulatedFloat with correct arguments", (function () {
                          return StakerSmocked.InternalMock._calculateAccumulatedFloatAndExecuteOutstandingShiftsCallCheck({
                                      marketIndex: marketIndex,
                                      user: user
                                    });
                        }));
                  it("doesn't call mintFloat", (function () {
                          Chai$1.expect(StakerSmocked.InternalMock._mintFloatFunction(undefined)).to.have.callCount(0);
                          
                        }));
                  it("doesn't mutate userIndexOfLastClaimed", (function () {
                          return LetOps.Await.let_(contracts.contents.staker.userIndexOfLastClaimedReward(marketIndex, user), (function (lastClaimed) {
                                        return Chai.bnEqual(undefined, lastClaimed, Globals.zeroBn);
                                      }));
                        }));
                  it("doesn't emit FloatMinted event", (function () {
                          return Chai.expectToNotEmit(Chai.callEmitEvents(promiseRef.contents, contracts.contents.staker, "FloatMinted"));
                        }));
                  
                }));
          
        }));
  
}

exports.test = test;
/* Chai Not a pure module */
