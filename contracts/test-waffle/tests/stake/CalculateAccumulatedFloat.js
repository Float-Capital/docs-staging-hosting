// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Chai = require("../../bindings/chai/Chai.js");
var LetOps = require("../../library/LetOps.js");
var Globals = require("../../library/Globals.js");
var Helpers = require("../../library/Helpers.js");
var Js_math = require("rescript/lib/js/js_math.js");
var CONSTANTS = require("../../CONSTANTS.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_int32 = require("rescript/lib/js/caml_int32.js");
var StakerSmocked = require("../../library/smock/StakerSmocked.js");
var LongShortSmocked = require("../../library/smock/LongShortSmocked.js");

function makeIterator(anyArray) {
  var indexRef = {
    contents: 0
  };
  return function (param) {
    var index = indexRef.contents;
    indexRef.contents = Caml_int32.mod_(index + 1 | 0, anyArray.length);
    return Belt_Array.getExn(anyArray, index);
  };
}

var smockedCalculateAccumulatedFloatInRangeMultiBinding = ((_r, arr) => _r._calculateAccumulatedFloatInRangeMock.returns(makeIterator(arr)));

function test(contracts) {
  describe("calculateAccumulatedFloat", (function () {
          var marketIndex = Js_math.random_int(1, 100000);
          var longToken = ethers.Wallet.createRandom().address;
          var shortToken = ethers.Wallet.createRandom().address;
          var user = ethers.Wallet.createRandom().address;
          var accumulativeFloatPerTokenUserLong = Helpers.randomTokenAmount(undefined);
          var accumulativeFloatPerTokenLatestLong = Globals.add(accumulativeFloatPerTokenUserLong, Helpers.randomTokenAmount(undefined));
          var newUserAmountStakedLong = Helpers.randomTokenAmount(undefined);
          var accumulativeFloatPerTokenUserShort = Helpers.randomTokenAmount(undefined);
          var accumulativeFloatPerTokenLatestShort = Globals.add(accumulativeFloatPerTokenUserShort, Helpers.randomTokenAmount(undefined));
          var newUserAmountStakedShort = Helpers.randomTokenAmount(undefined);
          it("[HAPPY] should correctly return the float tokens due for the user", (function () {
                  var match = contracts.contents;
                  var staker = match.staker;
                  var usersLatestClaimedReward = Helpers.randomInteger(undefined);
                  var newLatestRewardIndex = Globals.add(usersLatestClaimedReward, Helpers.randomInteger(undefined));
                  return LetOps.AwaitThen.let_(staker.setFloatRewardCalcParams(marketIndex, longToken, shortToken, newLatestRewardIndex, user, usersLatestClaimedReward, accumulativeFloatPerTokenLatestLong, accumulativeFloatPerTokenLatestShort, accumulativeFloatPerTokenUserLong, accumulativeFloatPerTokenUserShort, newUserAmountStakedLong, newUserAmountStakedShort), (function (param) {
                                return LetOps.Await.let_(staker.callStatic._calculateAccumulatedFloatAndExecuteOutstandingShiftsExposed(marketIndex, user), (function (floatDue) {
                                              var expectedFloatDueLong = Globals.div(Globals.mul(Globals.sub(accumulativeFloatPerTokenLatestLong, accumulativeFloatPerTokenUserLong), newUserAmountStakedLong), CONSTANTS.floatIssuanceFixedDecimal);
                                              var expectedFloatDueShort = Globals.div(Globals.mul(Globals.sub(accumulativeFloatPerTokenLatestShort, accumulativeFloatPerTokenUserShort), newUserAmountStakedShort), CONSTANTS.floatIssuanceFixedDecimal);
                                              return Chai.bnEqual("calculated float due is incorrect", floatDue, Globals.add(expectedFloatDueLong, expectedFloatDueShort));
                                            }));
                              }));
                }));
          it("should return zero if `usersLatestClaimedReward` is equal to `newLatestRewardIndex`", (function () {
                  var match = contracts.contents;
                  var staker = match.staker;
                  var newLatestRewardIndex = Helpers.randomInteger(undefined);
                  return LetOps.AwaitThen.let_(staker.setFloatRewardCalcParams(marketIndex, longToken, shortToken, newLatestRewardIndex, user, newLatestRewardIndex, accumulativeFloatPerTokenLatestLong, accumulativeFloatPerTokenLatestShort, accumulativeFloatPerTokenUserLong, accumulativeFloatPerTokenUserShort, newUserAmountStakedLong, newUserAmountStakedShort), (function (param) {
                                return LetOps.Await.let_(staker.callStatic._calculateAccumulatedFloatAndExecuteOutstandingShiftsExposed(marketIndex, user), (function (floatDue) {
                                              return Chai.bnEqual("calculated float due should be zero", floatDue, Globals.bnFromInt(0));
                                            }));
                              }));
                }));
          it("If the user has zero tokens staked they should get zero float tokens", (function () {
                  var match = contracts.contents;
                  var staker = match.staker;
                  var usersLatestClaimedReward = Helpers.randomInteger(undefined);
                  var newLatestRewardIndex = Globals.add(usersLatestClaimedReward, Helpers.randomInteger(undefined));
                  return LetOps.AwaitThen.let_(staker.setFloatRewardCalcParams(marketIndex, longToken, shortToken, newLatestRewardIndex, user, usersLatestClaimedReward, accumulativeFloatPerTokenLatestLong, accumulativeFloatPerTokenLatestShort, accumulativeFloatPerTokenUserLong, accumulativeFloatPerTokenUserShort, ethers.BigNumber.from(0), ethers.BigNumber.from(0)), (function (param) {
                                return LetOps.Await.let_(staker.callStatic._calculateAccumulatedFloatAndExecuteOutstandingShiftsExposed(marketIndex, user), (function (floatDue) {
                                              return Chai.bnEqual("calculated float due should be zero", floatDue, Globals.bnFromInt(0));
                                            }));
                              }));
                }));
          describe("User has pending token shifts", (function () {
                  var usersLatestClaimedReward = Helpers.randomInteger(undefined);
                  var rewardBeforeShiftInterval = Helpers.randomTokenAmount(undefined);
                  var rewardAfterShiftInterval = Helpers.randomTokenAmount(undefined);
                  var amountToShift = Helpers.randomTokenAmount(undefined);
                  var userNextPrice_stakedSyntheticTokenShiftIndex = Helpers.randomInteger(undefined);
                  var latestRewardIndex = Globals.add(userNextPrice_stakedSyntheticTokenShiftIndex, Globals.oneBn);
                  var newLatestRewardIndex = Globals.add(latestRewardIndex, Helpers.randomInteger(undefined));
                  var amountOfStakeShifted = Helpers.randomTokenAmount(undefined);
                  var amountStakedBothSidesInitially = Globals.add(amountToShift, amountOfStakeShifted);
                  var smockedLongShort = {
                    contents: undefined
                  };
                  var setup = function (isShiftFromLong) {
                    var match = contracts.contents;
                    var staker = match.staker;
                    return LetOps.AwaitThen.let_(StakerSmocked.InternalMock.setup(staker), (function (param) {
                                  return LetOps.AwaitThen.let_(StakerSmocked.InternalMock.setupFunctionForUnitTesting(staker, "_calculateAccumulatedFloat"), (function (param) {
                                                return LetOps.AwaitThen.let_(staker.setFloatRewardCalcParams(marketIndex, longToken, shortToken, newLatestRewardIndex, user, usersLatestClaimedReward, accumulativeFloatPerTokenLatestLong, accumulativeFloatPerTokenLatestShort, accumulativeFloatPerTokenUserLong, accumulativeFloatPerTokenUserShort, amountStakedBothSidesInitially, amountStakedBothSidesInitially), (function (param) {
                                                              return LetOps.AwaitThen.let_(staker.setShiftParams(marketIndex, user, isShiftFromLong ? amountToShift : Globals.zeroBn, isShiftFromLong ? Globals.zeroBn : amountToShift, userNextPrice_stakedSyntheticTokenShiftIndex, latestRewardIndex), (function (param) {
                                                                            return LetOps.AwaitThen.let_(LongShortSmocked.make(undefined), (function (longShortSmocked) {
                                                                                          return LetOps.AwaitThen.let_(staker.setLongShort(longShortSmocked.address), (function (param) {
                                                                                                        longShortSmocked.getAmountSyntheticTokenToMintOnTargetSide.returns(amountOfStakeShifted);
                                                                                                        smockedLongShort.contents = longShortSmocked;
                                                                                                        smockedCalculateAccumulatedFloatInRangeMultiBinding(StakerSmocked.InternalMock.internalRef.contents, [
                                                                                                              rewardBeforeShiftInterval,
                                                                                                              rewardAfterShiftInterval
                                                                                                            ]);
                                                                                                        return staker.callStatic._calculateAccumulatedFloatAndExecuteOutstandingShiftsExposed(marketIndex, user);
                                                                                                      }));
                                                                                        }));
                                                                          }));
                                                            }));
                                              }));
                                }));
                  };
                  var runTestsForSide = function (isShiftFromLong) {
                    it("Should sum up the correct amount of float", (function () {
                            return LetOps.Await.let_(setup(isShiftFromLong), (function (floatDue) {
                                          return Chai.bnEqual("calculated float due should be zero", floatDue, Globals.add(rewardBeforeShiftInterval, rewardAfterShiftInterval));
                                        }));
                          }));
                    it("it should call _calculateAccumulatedFloatInRange with the correct parameters", (function () {
                            return LetOps.Await.let_(setup(isShiftFromLong), (function (param) {
                                          var stakeIncreasedSide = Globals.add(amountStakedBothSidesInitially, amountOfStakeShifted);
                                          var stakeDecreasedSide = Globals.sub(amountStakedBothSidesInitially, amountToShift);
                                          StakerSmocked.InternalMock._calculateAccumulatedFloatInRangeCallCheck({
                                                marketIndex: marketIndex,
                                                amountStakedLong: amountStakedBothSidesInitially,
                                                amountStakedShort: amountStakedBothSidesInitially,
                                                rewardIndexFrom: usersLatestClaimedReward,
                                                rewardIndexTo: userNextPrice_stakedSyntheticTokenShiftIndex
                                              });
                                          return StakerSmocked.InternalMock._calculateAccumulatedFloatInRangeCallCheck({
                                                      marketIndex: marketIndex,
                                                      amountStakedLong: isShiftFromLong ? stakeDecreasedSide : stakeIncreasedSide,
                                                      amountStakedShort: isShiftFromLong ? stakeIncreasedSide : stakeDecreasedSide,
                                                      rewardIndexFrom: userNextPrice_stakedSyntheticTokenShiftIndex,
                                                      rewardIndexTo: latestRewardIndex
                                                    });
                                        }));
                          }));
                    it("it should call LongShort.getAmountSyntheticTokenToMintOnTargetSideCallCheck with the correct parameters", (function () {
                            return LetOps.Await.let_(setup(isShiftFromLong), (function (param) {
                                          return LongShortSmocked.getAmountSyntheticTokenToMintOnTargetSideCallCheck(smockedLongShort.contents, {
                                                      marketIndex: marketIndex,
                                                      amountSyntheticToken_redeemOnOriginSide: amountToShift,
                                                      isShiftFromLong: isShiftFromLong,
                                                      priceSnapshotIndex: userNextPrice_stakedSyntheticTokenShiftIndex
                                                    });
                                        }));
                          }));
                    it("it should reset " + ((
                            isShiftFromLong ? "userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long" : "userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short"
                          ) + " to zero."), (function () {
                            return LetOps.Await.let_(setup(isShiftFromLong), (function (param) {
                                          return LetOps.Await.let_(contracts.contents.staker._calculateAccumulatedFloatAndExecuteOutstandingShiftsExposed(marketIndex, user), (function (param) {
                                                        return LetOps.Await.let_(contracts.contents.staker.userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom(marketIndex, isShiftFromLong, user), (function (amountToShiftForSideAfter) {
                                                                      return Chai.bnEqual(undefined, amountToShiftForSideAfter, Globals.zeroBn);
                                                                    }));
                                                      }));
                                        }));
                          }));
                    
                  };
                  describe("Shift from Long", (function () {
                          return runTestsForSide(true);
                        }));
                  describe("Shift from Short", (function () {
                          return runTestsForSide(false);
                        }));
                  it("it should reset the users userNextPrice_stakedSyntheticTokenShiftIndex to zero", (function () {
                          return LetOps.Await.let_(setup(true), (function (param) {
                                        return LetOps.Await.let_(contracts.contents.staker._calculateAccumulatedFloatAndExecuteOutstandingShiftsExposed(marketIndex, user), (function (param) {
                                                      return LetOps.Await.let_(contracts.contents.staker.userNextPrice_stakedSyntheticTokenShiftIndex(marketIndex, user), (function (usersShiftIndex) {
                                                                    return Chai.bnEqual(undefined, usersShiftIndex, Globals.zeroBn);
                                                                  }));
                                                    }));
                                      }));
                        }));
                  
                }));
          
        }));
  
}

exports.makeIterator = makeIterator;
exports.smockedCalculateAccumulatedFloatInRangeMultiBinding = smockedCalculateAccumulatedFloatInRangeMultiBinding;
exports.test = test;
/* Chai Not a pure module */
