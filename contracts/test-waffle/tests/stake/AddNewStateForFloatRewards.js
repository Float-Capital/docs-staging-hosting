// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Chai = require("../../bindings/chai/Chai.js");
var LetOps = require("../../library/LetOps.js");
var Globals = require("../../library/Globals.js");
var Helpers = require("../../library/Helpers.js");
var CONSTANTS = require("../../CONSTANTS.js");
var StakerSmocked = require("../../library/smock/StakerSmocked.js");

function testUnit(contracts, param) {
  var marketIndex = Helpers.randomJsInteger(undefined);
  var match = Helpers.Tuple.make5(Helpers.randomInteger);
  var timeDeltaGreaterThanZero = match[4];
  var shortValue = match[3];
  var longValue = match[2];
  var shortPrice = match[1];
  var longPrice = match[0];
  describe("addNewStateForFloatRewards", (function () {
          Globals.before_once$p(function (param) {
                return StakerSmocked.InternalMock.setupFunctionForUnitTesting(contracts.contents.staker, "addNewStateForFloatRewards");
              });
          var setup = function (longShortMarketPriceSnapshotIndexIfShiftExecuted, timeDelta) {
            StakerSmocked.InternalMock.mock_calculateTimeDeltaToReturn(timeDelta);
            return contracts.contents.staker.addNewStateForFloatRewards(marketIndex, longPrice, shortPrice, longValue, shortValue, longShortMarketPriceSnapshotIndexIfShiftExecuted);
          };
          describe("modifiers", (function () {
                  it("calls the onlyLongShort modifier", (function () {
                          return LetOps.Await.let_(contracts.contents.staker.addNewStateForFloatRewards(marketIndex, longPrice, shortPrice, longValue, shortValue, Globals.zeroBn), (function (param) {
                                        return Chai.intEqual(undefined, StakerSmocked.InternalMock.onlyLongShortModifierLogicCalls(undefined).length, 1);
                                      }));
                        }));
                  
                }));
          describe("case timeDelta > 0", (function () {
                  var longShortMarketPriceSnapshotIndexIfShiftExecuted = Helpers.randomTokenAmount(undefined);
                  Globals.before_once$p(function (param) {
                        return setup(longShortMarketPriceSnapshotIndexIfShiftExecuted, timeDeltaGreaterThanZero);
                      });
                  it("calls calculateTimeDelta with correct arguments", (function () {
                          return Chai.recordArrayDeepEqualFlat(undefined, StakerSmocked.InternalMock._calculateTimeDeltaCalls(undefined), [{
                                        marketIndex: marketIndex
                                      }]);
                        }));
                  it("calls setRewardObjects with correct arguments", (function () {
                          return Chai.recordArrayDeepEqualFlat(undefined, StakerSmocked.InternalMock._setRewardObjectsCalls(undefined), [{
                                        marketIndex: marketIndex,
                                        longPrice: longPrice,
                                        shortPrice: shortPrice,
                                        longValue: longValue,
                                        shortValue: shortValue
                                      }]);
                        }));
                  
                }));
          describe("case longShortMarketPriceSnapshotIndexIfShiftExecuted > 0", (function () {
                  var nextTokenShiftIndex = Helpers.randomInteger(undefined);
                  var latestRewardIndex = Helpers.randomInteger(undefined);
                  var longShortMarketPriceSnapshotIndexIfShiftExecuted = Helpers.randomInteger(undefined);
                  var addNewStateForFloatRewardsTxPromise = {
                    contents: "Not set yet"
                  };
                  Globals.before_once$p(function (param) {
                        return LetOps.Await.let_(contracts.contents.staker.setAddNewStateForFloatRewardsGlobals(marketIndex, nextTokenShiftIndex, latestRewardIndex), (function (param) {
                                      addNewStateForFloatRewardsTxPromise.contents = setup(longShortMarketPriceSnapshotIndexIfShiftExecuted, timeDeltaGreaterThanZero);
                                      return addNewStateForFloatRewardsTxPromise.contents;
                                    }));
                      });
                  it("updates longShortMarketPriceSnapshotIndex to the 'longShortMarketPriceSnapshotIndexIfShiftExecuted' value recieved from long short", (function () {
                          return LetOps.Await.let_(contracts.contents.staker.longShortMarketPriceSnapshotIndex(nextTokenShiftIndex), (function (longShortMarketPriceSnapshotIndex) {
                                        return Chai.bnEqual(undefined, longShortMarketPriceSnapshotIndex, longShortMarketPriceSnapshotIndexIfShiftExecuted);
                                      }));
                        }));
                  it("increments the tokenShiftIndexToStakerStateMapping", (function () {
                          return LetOps.Await.let_(contracts.contents.staker.tokenShiftIndexToStakerStateMapping(nextTokenShiftIndex), (function (tokenShiftIndexToStakerStateMapping) {
                                        return Chai.bnEqual(undefined, tokenShiftIndexToStakerStateMapping, Globals.add(latestRewardIndex, Globals.oneBn));
                                      }));
                        }));
                  it("increments the nextTokenShiftIndex", (function () {
                          return LetOps.Await.let_(contracts.contents.staker.nextTokenShiftIndex(marketIndex), (function (updatedNextTokenShiftIndex) {
                                        return Chai.bnEqual(undefined, updatedNextTokenShiftIndex, Globals.add(nextTokenShiftIndex, Globals.oneBn));
                                      }));
                        }));
                  it("emits the SynthTokensShifted event", (function () {
                          return Chai.callEmitEvents(addNewStateForFloatRewardsTxPromise.contents, contracts.contents.staker, "SynthTokensShifted").withArgs();
                        }));
                  
                }));
          describe("case timeDelta == 0", (function () {
                  it("doesn't call setRewardObjects", (function () {
                          return LetOps.Await.let_(setup(Globals.zeroBn, CONSTANTS.zeroBn), (function (param) {
                                        return Chai.recordArrayDeepEqualFlat(undefined, StakerSmocked.InternalMock._setRewardObjectsCalls(undefined), []);
                                      }));
                        }));
                  
                }));
          
        }));
  
}

exports.testUnit = testUnit;
/* Chai Not a pure module */
