// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Chai = require("../../bindings/chai/Chai.js");
var Chai$1 = require("chai");
var LetOps = require("../../library/LetOps.js");
var Globals = require("../../library/Globals.js");
var Helpers = require("../../library/Helpers.js");
var StakerSmocked = require("../../library/smock/StakerSmocked.js");
var LongShortSmocked = require("../../library/smock/LongShortSmocked.js");

function testUnit(contracts, accounts) {
  describe("shiftTokens", (function () {
          var marketIndex = Helpers.randomJsInteger(undefined);
          var amountSyntheticTokensToShift = Helpers.randomTokenAmount(undefined);
          var amountSyntheticTokensToShiftBeforeValue = Helpers.randomTokenAmount(undefined);
          Globals.before_once$p(function (param) {
                var match = contracts.contents;
                return LetOps.Await.let_(match.staker.setLongShort(match.longShortSmocked.address), (function (param) {
                              return StakerSmocked.InternalMock.setupFunctionForUnitTesting(contracts.contents.staker, "shiftTokens");
                            }));
              });
          var setup = function (isShiftFromLong, amountSyntheticTokensToShiftBeforeValue, amountSyntheticTokensToShift, userNextPrice_stakedSyntheticTokenShiftIndex, latestRewardIndex, userAmountStaked) {
            var user = accounts.contents[0].address;
            var match = contracts.contents;
            var staker = match.staker;
            return LetOps.Await.let_(staker.setShiftTokensParams(marketIndex, isShiftFromLong, user, amountSyntheticTokensToShiftBeforeValue, userAmountStaked, userNextPrice_stakedSyntheticTokenShiftIndex, latestRewardIndex, match.syntheticTokenSmocked.address), (function (param) {
                          return staker.shiftTokens(amountSyntheticTokensToShift, marketIndex, isShiftFromLong);
                        }));
          };
          it("reverts if market doesn't exist or user doesn't have any staked tokens", (function () {
                  return Chai.expectRevert(contracts.contents.staker.shiftTokens(amountSyntheticTokensToShift, marketIndex, true), "Not enough tokens to shift");
                }));
          it("calls _mintAccumulatedFloatAndExecuteOutstandingShifts (via modifier) with the correct arguments if the user has a 'confirmed' shift that needs to be settled", (function () {
                  var user = accounts.contents[0].address;
                  var userNextPrice_stakedSyntheticTokenShiftIndex = Helpers.randomInteger(undefined);
                  var latestRewardIndex = Globals.add(userNextPrice_stakedSyntheticTokenShiftIndex, Helpers.randomInteger(undefined));
                  return LetOps.Await.let_(setup(true, amountSyntheticTokensToShiftBeforeValue, amountSyntheticTokensToShift, userNextPrice_stakedSyntheticTokenShiftIndex, latestRewardIndex, Globals.add(amountSyntheticTokensToShift, amountSyntheticTokensToShiftBeforeValue)), (function (param) {
                                return StakerSmocked.InternalMock._updateUsersStakedPosition_mintAccumulatedFloatAndExecuteOutstandingShiftsCallCheck({
                                            marketIndex: marketIndex,
                                            user: user
                                          });
                              }));
                }));
          it("doesn't call _mintAccumulatedFloatAndExecuteOutstandingShifts if userNextPrice_stakedSyntheticTokenShiftIndex == 0", (function () {
                  var latestRewardIndex = Helpers.randomInteger(undefined);
                  return LetOps.Await.let_(setup(true, amountSyntheticTokensToShiftBeforeValue, amountSyntheticTokensToShift, Globals.zeroBn, latestRewardIndex, Globals.add(amountSyntheticTokensToShift, amountSyntheticTokensToShiftBeforeValue)), (function (param) {
                                Chai$1.expect(StakerSmocked.InternalMock._mintAccumulatedFloatAndExecuteOutstandingShiftsFunction(undefined)).to.have.callCount(0);
                                
                              }));
                }));
          it("doesn't call _mintAccumulatedFloatAndExecuteOutstandingShifts if userNextPrice_stakedSyntheticTokenShiftIndex == latestRewardIndex", (function () {
                  var userNextPrice_stakedSyntheticTokenShiftIndex = Helpers.randomInteger(undefined);
                  return LetOps.Await.let_(setup(true, amountSyntheticTokensToShiftBeforeValue, amountSyntheticTokensToShift, userNextPrice_stakedSyntheticTokenShiftIndex, userNextPrice_stakedSyntheticTokenShiftIndex, Globals.add(amountSyntheticTokensToShift, amountSyntheticTokensToShiftBeforeValue)), (function (param) {
                                Chai$1.expect(StakerSmocked.InternalMock._mintAccumulatedFloatAndExecuteOutstandingShiftsFunction(undefined)).to.have.callCount(0);
                                
                              }));
                }));
          it("doesn't call _mintAccumulatedFloatAndExecuteOutstandingShifts if userNextPrice_stakedSyntheticTokenShiftIndex > latestRewardIndex", (function () {
                  var latestRewardIndex = Helpers.randomInteger(undefined);
                  var userNextPrice_stakedSyntheticTokenShiftIndex = Globals.add(latestRewardIndex, Helpers.randomInteger(undefined));
                  return LetOps.Await.let_(setup(true, amountSyntheticTokensToShiftBeforeValue, amountSyntheticTokensToShift, userNextPrice_stakedSyntheticTokenShiftIndex, latestRewardIndex, Globals.add(amountSyntheticTokensToShift, amountSyntheticTokensToShiftBeforeValue)), (function (param) {
                                Chai$1.expect(StakerSmocked.InternalMock._mintAccumulatedFloatAndExecuteOutstandingShiftsFunction(undefined)).to.have.callCount(0);
                                
                              }));
                }));
          it("sets the userNextPrice_stakedSyntheticTokenShiftIndex for the user to latestRewardIndex + 1", (function () {
                  var latestRewardIndex = Helpers.randomInteger(undefined);
                  var user = accounts.contents[0].address;
                  return LetOps.Await.let_(setup(true, amountSyntheticTokensToShiftBeforeValue, amountSyntheticTokensToShift, Globals.zeroBn, latestRewardIndex, Globals.add(amountSyntheticTokensToShift, amountSyntheticTokensToShiftBeforeValue)), (function (param) {
                                return LetOps.Await.let_(contracts.contents.staker.userNextPrice_stakedSyntheticTokenShiftIndex(marketIndex, user), (function (userNextPrice_stakedSyntheticTokenShiftIndexAfter) {
                                              return Chai.bnEqual(undefined, userNextPrice_stakedSyntheticTokenShiftIndexAfter, Globals.add(latestRewardIndex, Globals.oneBn));
                                            }));
                              }));
                }));
          var sideSpecificTests = function (isShiftFromLong) {
            it("calls the shiftPositionFrom" + ((
                    isShiftFromLong ? "Long" : "Short"
                  ) + "NextPrice function on long short with the correct parameters"), (function () {
                    var match = contracts.contents;
                    var longShortSmocked = match.longShortSmocked;
                    var latestRewardIndex = Helpers.randomInteger(undefined);
                    return LetOps.Await.let_(setup(isShiftFromLong, amountSyntheticTokensToShiftBeforeValue, amountSyntheticTokensToShift, Globals.zeroBn, latestRewardIndex, Globals.add(amountSyntheticTokensToShift, amountSyntheticTokensToShiftBeforeValue)), (function (param) {
                                  return LongShortSmocked.shiftPositionNextPriceCallCheck(longShortSmocked, {
                                              marketIndex: marketIndex,
                                              amountSyntheticTokensToShift: amountSyntheticTokensToShift,
                                              isShiftFromLong: isShiftFromLong
                                            });
                                }));
                  }));
            it("updates the amountToShiftFrom" + ((
                    isShiftFromLong ? "Long" : "Short"
                  ) + "User value with the amount to shift"), (function () {
                    var latestRewardIndex = Helpers.randomInteger(undefined);
                    var user = accounts.contents[0].address;
                    return LetOps.Await.let_(setup(isShiftFromLong, amountSyntheticTokensToShiftBeforeValue, amountSyntheticTokensToShift, Globals.zeroBn, latestRewardIndex, Globals.add(amountSyntheticTokensToShift, amountSyntheticTokensToShiftBeforeValue)), (function (param) {
                                  return LetOps.Await.let_(contracts.contents.staker.userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom(marketIndex, isShiftFromLong, user), (function (totalAmountToShiftFromSide) {
                                                return Chai.bnEqual(undefined, totalAmountToShiftFromSide, Globals.add(amountSyntheticTokensToShiftBeforeValue, amountSyntheticTokensToShift));
                                              }));
                                }));
                  }));
            
          };
          describe("Shift from Long", (function () {
                  return sideSpecificTests(true);
                }));
          describe("Shift from Short", (function () {
                  return sideSpecificTests(false);
                }));
          
        }));
  
}

exports.testUnit = testUnit;
/* Chai Not a pure module */
