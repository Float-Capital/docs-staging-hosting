// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Chai = require("../../bindings/chai/Chai.js");
var Chai$1 = require("chai");
var Js_int = require("rescript/lib/js/js_int.js");
var LetOps = require("../../library/LetOps.js");
var Globals = require("../../library/Globals.js");
var Helpers = require("../../library/Helpers.js");
var Js_math = require("rescript/lib/js/js_math.js");
var CONSTANTS = require("../../CONSTANTS.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var StakerSmocked = require("../../library/smock/StakerSmocked.js");
var LongShortSmocked = require("../../library/smock/LongShortSmocked.js");

function test(contracts, accounts) {
  describe("stakeFromUser", (function () {
          var marketIndexForToken = Helpers.randomJsInteger(undefined);
          var latestRewardIndex = ethers.BigNumber.from(Js_math.random_int(2, Js_int.max));
          var randomRewardIndexBelow = function (num) {
            return ethers.BigNumber.from(Js_math.random_int(1, num.toNumber()));
          };
          var from = Helpers.randomAddress(undefined);
          var mockTokenWalletRef = {
            contents: undefined
          };
          var match = Helpers.Tuple.make2(Helpers.randomTokenAmount);
          var userAmountToStake = match[1];
          var userAmountStaked = match[0];
          var promiseRef = {
            contents: undefined
          };
          var setup = function (userLastRewardIndex, latestRewardIndex) {
            var match = contracts.contents;
            var longShortSmocked = match.longShortSmocked;
            return LetOps.Await.let_(StakerSmocked.InternalMock.setupFunctionForUnitTesting(match.staker, "stakeFromUser"), (function (param) {
                          mockTokenWalletRef.contents = Belt_Array.getExn(accounts.contents, 6);
                          return LetOps.Await.let_(contracts.contents.staker.setStakeFromUserParams(longShortSmocked.address, mockTokenWalletRef.contents.address, marketIndexForToken, from, latestRewardIndex, userAmountStaked, userLastRewardIndex), (function (param) {
                                        var promise = contracts.contents.staker.connect(mockTokenWalletRef.contents).stakeFromUser(from, userAmountToStake);
                                        promiseRef.contents = promise;
                                        return promise;
                                      }));
                        }));
          };
          it.skip("calls onlyValidSynthetic with correct args", (function () {
                  
                }));
          it("calls updateSystemState on longshort with correct args", (function () {
                  var match = contracts.contents;
                  var longShortSmocked = match.longShortSmocked;
                  return LetOps.Await.let_(setup(randomRewardIndexBelow(latestRewardIndex), latestRewardIndex), (function (param) {
                                return LongShortSmocked.updateSystemStateCallCheck(longShortSmocked, {
                                            marketIndex: marketIndexForToken
                                          });
                              }));
                }));
          describe("case user has outstanding float to be minted", (function () {
                  Globals.before_once$p(function (param) {
                        return setup(randomRewardIndexBelow(latestRewardIndex), latestRewardIndex);
                      });
                  it("calls mintAccumulatedFloat with correct args", (function () {
                          return StakerSmocked.InternalMock._mintAccumulatedFloatAndExecuteOutstandingShiftsCallCheck({
                                      marketIndex: marketIndexForToken,
                                      user: from
                                    });
                        }));
                  it("mutates userAmountStaked", (function () {
                          return LetOps.Await.let_(contracts.contents.staker.userAmountStaked(mockTokenWalletRef.contents.address, from), (function (amountStaked) {
                                        return Chai.bnEqual(undefined, amountStaked, userAmountStaked.add(userAmountToStake));
                                      }));
                        }));
                  it("mutates userIndexOfLastClaimedReward", (function () {
                          return LetOps.Await.let_(contracts.contents.staker.userIndexOfLastClaimedReward(marketIndexForToken, from), (function (lastClaimedReward) {
                                        return Chai.bnEqual(undefined, lastClaimedReward, latestRewardIndex);
                                      }));
                        }));
                  it("emits StakeAdded", (function () {
                          return Chai.callEmitEvents(promiseRef.contents, contracts.contents.staker, "StakeAdded").withArgs(from, mockTokenWalletRef.contents.address, userAmountToStake, latestRewardIndex);
                        }));
                  
                }));
          describe("case user has last claimed index of 0", (function () {
                  Globals.before_once$p(function (param) {
                        return setup(CONSTANTS.zeroBn, Helpers.randomInteger(undefined));
                      });
                  it("doesn't call mintAccumulatedFloat", (function () {
                          Chai$1.expect(StakerSmocked.InternalMock._mintAccumulatedFloatAndExecuteOutstandingShiftsFunction(undefined)).to.have.callCount(0);
                          
                        }));
                  
                }));
          describe("case users last claimed index == latestRewardIndex for market", (function () {
                  var index = Helpers.randomInteger(undefined);
                  Globals.before_once$p(function (param) {
                        return setup(index, index);
                      });
                  it("doesn't call mintAccumulatedFloat", (function () {
                          Chai$1.expect(StakerSmocked.InternalMock._mintAccumulatedFloatAndExecuteOutstandingShiftsFunction(undefined)).to.have.callCount(0);
                          
                        }));
                  
                }));
          
        }));
  
}

exports.test = test;
/* Chai Not a pure module */
