// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Chai = require("../bindings/chai/Chai.js");
var Curry = require("rescript/lib/js/curry.js");
var Helpers = require("../library/Helpers.js");
var Contract = require("../library/Contract.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");

function let_(prom, cb) {
  return prom.then(Curry.__1(cb));
}

var Await = {
  let_: let_
};

function let_$1(prom, cb) {
  return prom.then(Curry.__1(cb));
}

var AwaitM = {
  let_: let_$1
};

function test(markets, accounts, contracts, done_) {
  var testUser = accounts[1];
  var longShort = contracts.longShort;
  var staker = contracts.staker;
  var synthsUserHasStaked = {
    contents: []
  };
  var marketsUserHasStakedIn = {
    contents: []
  };
  var prom = Promise.all(Belt_Array.map(contracts.markets, (function (param) {
              var marketIndex = param.marketIndex;
              var shortSynth = param.shortSynth;
              var paymentToken = param.paymentToken;
              var mintStake = function (param) {
                return function (param$1) {
                  return Helpers.mintAndStake(marketIndex, param, paymentToken, testUser, longShort, param$1);
                };
              };
              marketsUserHasStakedIn.contents = Belt_Array.concat(marketsUserHasStakedIn.contents, [marketIndex]);
              var amount = Helpers.randomMintLongShort(undefined);
              switch (amount.TAG | 0) {
                case /* Long */0 :
                    synthsUserHasStaked.contents = Belt_Array.concat(synthsUserHasStaked.contents, [param.longSynth]);
                    return mintStake(amount._0)(true);
                case /* Short */1 :
                    synthsUserHasStaked.contents = Belt_Array.concat(synthsUserHasStaked.contents, [shortSynth]);
                    return mintStake(amount._0)(false);
                case /* Both */2 :
                    var shortAmount = amount._1;
                    synthsUserHasStaked.contents = Belt_Array.concat(synthsUserHasStaked.contents, [
                          shortSynth,
                          shortSynth
                        ]);
                    return mintStake(amount._0)(true).then(function (param) {
                                return mintStake(shortAmount)(false);
                              });
                
              }
            })));
  return prom.then(function (thing) {
              var prom = Contract.Staker.claimFloatCustomUser(staker, testUser, synthsUserHasStaked.contents, marketsUserHasStakedIn.contents);
              return prom.then(function (another) {
                          var prom = Promise.all(Belt_Array.map(synthsUserHasStaked.contents, (function (synth) {
                                      return Promise.all([
                                                    staker.userIndexOfLastClaimedReward(synth.address, testUser.address),
                                                    staker.latestRewardIndex(synth.address)
                                                  ]).then(function (param) {
                                                  return Chai.bnEqual(param[0], param[1]);
                                                });
                                    })));
                          return prom.then(function (other) {
                                      return Curry._1(done_, undefined);
                                    });
                        });
            });
}

exports.Await = Await;
exports.AwaitM = AwaitM;
exports.test = test;
/* Chai Not a pure module */
