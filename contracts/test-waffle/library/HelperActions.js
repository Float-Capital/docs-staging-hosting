// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var LetOps = require("./LetOps.js");
var Globals = require("./Globals.js");
var Helpers = require("./Helpers.js");
var Contract = require("./Contract.js");
var CONSTANTS = require("../CONSTANTS.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");

function mintDirect(marketIndex, amount, token, user, longShort, oracleManagerMock, isLong) {
  return LetOps.AwaitThen.let_(Contract.PaymentTokenHelpers.mintAndApprove(token, user, amount, longShort.address), (function (param) {
                var contract = longShort.connect(user);
                return LetOps.AwaitThen.let_(oracleManagerMock.getLatestPrice(), (function (currentOraclePrice) {
                              var tempOraclePrice = Globals.add(currentOraclePrice, Globals.bnFromInt(1));
                              oracleManagerMock.setPrice(tempOraclePrice);
                              return LetOps.AwaitThen.let_(contract._updateSystemState(marketIndex), (function (param) {
                                            return LetOps.AwaitThen.let_(isLong ? contract.mintLongNextPrice(marketIndex, amount) : contract.mintShortNextPrice(marketIndex, amount), (function (_mintNextPrice) {
                                                          oracleManagerMock.setPrice(currentOraclePrice);
                                                          return contract._updateSystemState(marketIndex);
                                                        }));
                                          }));
                            }));
              }));
}

function mintAndStakeDirect(marketIndex, amount, token, user, longShort, oracleManagerMock, synthToken) {
  return LetOps.AwaitThen.let_(Contract.SyntheticTokenHelpers.getIsLong(synthToken), (function (isLong) {
                return LetOps.AwaitThen.let_(synthToken.balanceOf(user.address), (function (balanceBeforeMinting) {
                              return LetOps.AwaitThen.let_(mintDirect(marketIndex, amount, token, user, longShort, oracleManagerMock, isLong), (function (_mintDirect) {
                                            return LetOps.AwaitThen.let_(synthToken.balanceOf(user.address), (function (availableToStakeAfter) {
                                                          var amountToStake = Globals.sub(availableToStakeAfter, balanceBeforeMinting);
                                                          var synthTokenConnected = synthToken.connect(user);
                                                          return synthTokenConnected.stake(amountToStake);
                                                        }));
                                          }));
                            }));
              }));
}

function stakeRandomlyInMarkets(marketsToStakeIn, userToStakeWith, longShort) {
  return Belt_Array.reduce([marketsToStakeIn[0]], Promise.resolve([
                  [],
                  []
                ]), (function (currentValues, param) {
                var marketIndex = param.marketIndex;
                var shortSynth = param.shortSynth;
                var longSynth = param.longSynth;
                var oracleManager = param.oracleManager;
                var paymentToken = param.paymentToken;
                return LetOps.AwaitThen.let_(currentValues, (function (param) {
                              var marketsUserHasStakedIn = param[1];
                              var synthsUserHasStakedIn = param[0];
                              var mintStake = function (param) {
                                return function (param$1) {
                                  return mintAndStakeDirect(marketIndex, param, paymentToken, userToStakeWith, longShort, oracleManager, param$1);
                                };
                              };
                              return LetOps.AwaitThen.let_(Contract.LongShortHelpers.getMarketBalance(longShort, marketIndex), (function (param) {
                                            var valueShortBefore = param.shortValue;
                                            var valueLongBefore = param.longValue;
                                            var amount = Helpers.randomMintLongShort(undefined);
                                            var tmp;
                                            switch (amount.TAG | 0) {
                                              case /* Long */0 :
                                                  var amount$1 = amount._0;
                                                  tmp = LetOps.AwaitThen.let_(mintStake(amount$1)(longSynth), (function (param) {
                                                          return LetOps.Await.let_(longShort.syntheticTokenPrice(marketIndex, CONSTANTS.longTokenType), (function (longTokenPrice) {
                                                                        return Belt_Array.concat(synthsUserHasStakedIn, [{
                                                                                      marketIndex: marketIndex,
                                                                                      synth: longSynth,
                                                                                      amount: amount$1,
                                                                                      priceOfSynthForAction: longTokenPrice,
                                                                                      valueInEntrySide: valueLongBefore,
                                                                                      valueInOtherSide: valueShortBefore
                                                                                    }]);
                                                                      }));
                                                        }));
                                                  break;
                                              case /* Short */1 :
                                                  var amount$2 = amount._0;
                                                  tmp = LetOps.AwaitThen.let_(mintStake(amount$2)(shortSynth), (function (param) {
                                                          return LetOps.Await.let_(longShort.syntheticTokenPrice(marketIndex, CONSTANTS.shortTokenType), (function (shortTokenPrice) {
                                                                        return Belt_Array.concat(synthsUserHasStakedIn, [{
                                                                                      marketIndex: marketIndex,
                                                                                      synth: shortSynth,
                                                                                      amount: amount$2,
                                                                                      priceOfSynthForAction: shortTokenPrice,
                                                                                      valueInEntrySide: valueShortBefore,
                                                                                      valueInOtherSide: valueLongBefore
                                                                                    }]);
                                                                      }));
                                                        }));
                                                  break;
                                              case /* Both */2 :
                                                  var shortAmount = amount._1;
                                                  var longAmount = amount._0;
                                                  tmp = LetOps.AwaitThen.let_(mintStake(longAmount)(longSynth), (function (param) {
                                                          return LetOps.AwaitThen.let_(longShort.syntheticTokenPrice(marketIndex, CONSTANTS.longTokenType), (function (longTokenPrice) {
                                                                        var newSynthsUserHasStakedIn = Belt_Array.concat(synthsUserHasStakedIn, [{
                                                                                marketIndex: marketIndex,
                                                                                synth: longSynth,
                                                                                amount: longAmount,
                                                                                priceOfSynthForAction: longTokenPrice,
                                                                                valueInEntrySide: valueLongBefore,
                                                                                valueInOtherSide: valueShortBefore
                                                                              }]);
                                                                        return LetOps.AwaitThen.let_(Contract.LongShortHelpers.getMarketBalance(longShort, marketIndex), (function (param) {
                                                                                      var valueShortBefore = param.shortValue;
                                                                                      var valueLongBefore = param.longValue;
                                                                                      return LetOps.AwaitThen.let_(mintStake(shortAmount)(shortSynth), (function (param) {
                                                                                                    return LetOps.Await.let_(longShort.syntheticTokenPrice(marketIndex, CONSTANTS.shortTokenType), (function (shortTokenPrice) {
                                                                                                                  return Belt_Array.concat(newSynthsUserHasStakedIn, [{
                                                                                                                                marketIndex: marketIndex,
                                                                                                                                synth: shortSynth,
                                                                                                                                amount: shortAmount,
                                                                                                                                priceOfSynthForAction: shortTokenPrice,
                                                                                                                                valueInEntrySide: valueShortBefore,
                                                                                                                                valueInOtherSide: valueLongBefore
                                                                                                                              }]);
                                                                                                                }));
                                                                                                  }));
                                                                                    }));
                                                                      }));
                                                        }));
                                                  break;
                                              
                                            }
                                            return LetOps.Await.let_(tmp, (function (newSynthsUserHasStakedIn) {
                                                          return [
                                                                  newSynthsUserHasStakedIn,
                                                                  Belt_Array.concat(marketsUserHasStakedIn, [marketIndex])
                                                                ];
                                                        }));
                                          }));
                            }));
              }));
}

function stakeRandomlyInBothSidesOfMarket(marketsToStakeIn, userToStakeWith, longShort) {
  return Belt_Array.reduce(marketsToStakeIn, Promise.resolve(undefined), (function (prevPromise, param) {
                var marketIndex = param.marketIndex;
                var shortSynth = param.shortSynth;
                var longSynth = param.longSynth;
                var oracleManager = param.oracleManager;
                var paymentToken = param.paymentToken;
                return LetOps.AwaitThen.let_(prevPromise, (function (param) {
                              var mintStake = function (param) {
                                return function (param$1) {
                                  return mintAndStakeDirect(marketIndex, param, paymentToken, userToStakeWith, longShort, oracleManager, param$1);
                                };
                              };
                              return LetOps.AwaitThen.let_(mintStake(Helpers.randomTokenAmount(undefined))(longSynth), (function (param) {
                                            return LetOps.Await.let_(mintStake(Helpers.randomTokenAmount(undefined))(shortSynth), (function (param) {
                                                          
                                                        }));
                                          }));
                            }));
              }));
}

exports.mintDirect = mintDirect;
exports.mintAndStakeDirect = mintAndStakeDirect;
exports.stakeRandomlyInMarkets = stakeRandomlyInMarkets;
exports.stakeRandomlyInBothSidesOfMarket = stakeRandomlyInBothSidesOfMarket;
/* Helpers Not a pure module */
