let allStateChangesRaw = Queries.getAllStateChanges()
let filePreRamble = `// Generated by Codegen.res, PLEASE EDIT WITH CARE

open ConverterTypes`
let typesString = ref(``)
let converterStringHead = `let covertToStateChange = (eventName, paramsObject) => {
  // TODO: throw a (descriptive) error if the array of parameters is the wrong length (or make a separate test?)
  // TODO: turn \`eventName\` into a polymorphic variant (create a decoder for it) (for undefined make it #unclassified(string)
  switch eventName {`
let converterStringTail = `  | name => Unclassified({name: name, data: paramsObject})
  }
}`
let converterString = ref(converterStringHead)
let variantTypeString = ref(`type stateChanges =
  | Unclassified(unclassifiedEvent)`)

let lowercaseFirstLetter = %raw(`(word) => word.charAt(0).toLowerCase() + word.slice(1)`)

let paramTypeToRescriptType = paramType =>
  switch paramType {
  | "uint32"
  | "uint256" => "bn"
  | "string" => "string"
  | "address" => "address"
  | unkownType =>
    Js.log(`Please handle all types - ${unkownType} isn't handled by this script.`)
    "unkownType"
  }

let _ = allStateChangesRaw->JsPromise.map(allStateChanges => {
  let uniqueStateChangeTypes = Js.Dict.empty()
  allStateChanges->Array.forEach(({txEventParamList}) =>
    txEventParamList->Array.forEach(({eventName, params}) => {
      let eventGenerated = uniqueStateChangeTypes->Js.Dict.get(eventName)->Option.isNone

      if eventGenerated {
        uniqueStateChangeTypes->Js.Dict.set(eventName, "set")
        let recordFields = params->Array.reduce(``, (acc, {paramType, paramName}) =>
          acc ++
          `
  ${paramName}: ${paramType->paramTypeToRescriptType},`
        )

        let eventDataTypeName = `${eventName->lowercaseFirstLetter}Data`
        typesString :=
          typesString.contents ++
          `
@decco.decode
type ${eventDataTypeName} = {${recordFields}
}`

        converterString :=
          converterString.contents ++
          `
  | "${eventName}" => ${eventName}(paramsObject->Js.Json.object_->${eventDataTypeName}_decode->Result.getExn)`

        variantTypeString :=
          variantTypeString.contents ++
          `
  | ${eventName}(${eventDataTypeName})`
        ()
      }
    })
  )

  Js.log(
    `${filePreRamble}
${typesString.contents}

${variantTypeString.contents}

${converterString.contents}
${converterStringTail}
`,
  )
  ()
})
