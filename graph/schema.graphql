type EventParam @entity {
  id: ID!
  index: Int!
  param: String!
  paramName: String!
  paramType: String!
}

type EventParams @entity {
  id: ID!
  index: Int!
  eventName: String!
  params: [EventParam!]!
}

type StateChange @entity {
  id: ID! # tx
  timestamp: BigInt!
  blockNumber: BigInt!
  gasUsed: BigInt!
  txEventParamList: [EventParams!]!
  affectedUsers: [User!]!
  affectedStakes: [CurrentStake!]!
}

type Event @entity {
  id: ID!
  address: Bytes!
}

type Price @entity {
  id: ID! # <marketIndex>-<long/short>-<timestamp>
  price: BigInt!
  timeUpdated: BigInt!
  token: SyntheticToken!
}

type LatestPrice @entity {
  id: ID! # latestPrice-<marketIndex>-<long/short>
  price: Price!
}

type SystemState @entity {
  id: ID! # marketIndex "-" callCounter
  timestamp: BigInt!
  txHash: Bytes!
  blockNumber: BigInt!
  marketIndex: BigInt!
  syntheticPrice: BigInt! # TODO: this should be a reference to another entity that holds the price
  longTokenPrice: LatestPrice!
  shortTokenPrice: LatestPrice!
  longToken: SyntheticToken!
  shortToken: SyntheticToken!
  totalLockedLong: BigInt!
  totalLockedShort: BigInt!
  totalValueLocked: BigInt!
  setBy: Bytes! #Turn into a User entity
}

type FeeStructure @entity {
  id: ID!
  baseEntryFee: BigInt!
  badLiquidityEntryFee: BigInt!
  baseExitFee: BigInt!
  badLiquidityExitFee: BigInt!
}

interface GenericTransfer {
  id: ID!
  from: String!
  to: String!
  value: BigInt!
}

type Transfer implements GenericTransfer @entity {
  id: ID!
  from: String!
  to: String!
  value: BigInt!
  token: SyntheticToken!
}

type CollateralTransfer implements GenericTransfer @entity {
  id: ID!
  from: String!
  to: String!
  value: BigInt!
  token: CollateralToken!
}

enum TokenType {
  Long
  Short
}

type SyntheticToken @entity {
  id: ID! # token address
  tokenAddress: Bytes!
  syntheticMarket: SyntheticMarket!
  tokenType: TokenType!
  totalStaked: BigInt!
  tokenSupply: BigInt!
  floatMintedFromSpecificToken: BigInt!
  latestPrice: LatestPrice!
  priceHistory: [Price!]!
}

type CollateralToken @entity {
  id: ID! # token address
  linkedMarkets: [SyntheticMarket!]!
}

type TokenApproval @entity {
  id: ID! # userAddress-tokenAddress
  collateralToken: CollateralToken!
  user: User!
  approvedInnacurate: BigInt!
  timestamp: BigInt!
}

type UserCollateralTokenApproval @entity {
  id: ID! # userAddress-tokenAddress
  approvalsHistory: [TokenApproval!]!
  updateTimestamp: BigInt!
  collateralToken: CollateralToken!
  currentApproval: TokenApproval!
}

type UserCollateralTokenBalance @entity {
  id: ID! # token address - user address - "balance"
  timeLastUpdated: BigInt!
  collateralToken: CollateralToken!
  user: User!
  balanceInaccurate: BigInt!
}

type SyntheticMarket @entity {
  id: ID! # ID -> Market Index
  timestampCreated: BigInt!
  txHash: Bytes!
  blockNumberCreated: BigInt!
  collateralToken: CollateralToken!
  name: String!
  symbol: String!
  marketIndex: BigInt!
  oracleAddress: Bytes!
  latestStakerState: StakeState!
  previousOracleAddresses: [Bytes!]!
  syntheticLong: SyntheticToken!
  syntheticShort: SyntheticToken!
  latestSystemState: SystemState!
  feeStructure: FeeStructure!
  kPeriod: BigInt!
  kMultiplier: BigInt!
  totalFloatMinted: BigInt!
}

type User @entity {
  id: ID! # ID -> Public address
  address: Bytes!
  totalMintedFloat: BigInt!
  floatTokenBalance: BigInt!
  timestampJoined: BigInt!
  totalGasUsed: BigInt!
  numberOfTransactions: BigInt!
  currentStakes: [CurrentStake!]!
  stateChangesAffectingUser: [StateChange!]!
  tokenBalances: [UserSyntheticTokenBalance!]!
  collatoralBalances: [UserCollateralTokenBalance!]!
  tokenMints: [UserSyntheticTokenMinted!]!
  collatoralTokenApprovals: [UserCollateralTokenApproval!]!
}

type UserSyntheticTokenBalance @entity {
  id: ID! # token address - user address - "balance"
  timeLastUpdated: BigInt!
  syntheticToken: SyntheticToken!
  user: User!
  tokenBalance: BigInt!
}

type UserSyntheticTokenMinted @entity {
  id: ID! # token address - user address - "minted"
  syntheticToken: SyntheticToken!
  user: User!
  tokensMinted: BigInt!
}

type CurrentStake @entity {
  id: ID! # token address - user address - "currentStake"
  user: User!
  userAddress: Bytes!
  syntheticToken: SyntheticToken!
  currentStake: Stake!
  lastMintState: StakeState!
}

type Stake @entity {
  id: ID! # "txHashString"
  timestamp: BigInt!
  blockNumber: BigInt!
  creationTxHash: Bytes!
  syntheticToken: SyntheticToken!
  user: User!
  amount: BigInt!
  withdrawn: Boolean!
}

type StakeState @entity {
  id: ID! # token address - state indexed
  blockNumber: BigInt!
  creationTxHash: Bytes!
  stateIndex: BigInt! #
  longToken: SyntheticToken!
  shortToken: SyntheticToken!
  timestamp: BigInt!
  accumulativeFloatPerTokenLong: BigInt!
  accumulativeFloatPerTokenShort: BigInt!
  floatRatePerTokenOverIntervalLong: BigInt!
  floatRatePerTokenOverIntervalShort: BigInt!
  timeSinceLastUpdate: BigInt!
}

type YieldManager @entity {
  id: ID!
  address: Bytes!
}

type OracleAggregator @entity {
  id: ID!
  address: Bytes!
}

type Staker @entity {
  id: ID!
  address: Bytes!
}

type TokenFactory @entity {
  id: ID!
  address: Bytes!
}

type LongShortContract @entity {
  id: ID!
  address: Bytes!
}

type GlobalState @entity {
  id: ID!
  contractVersion: BigInt!
  latestMarketIndex: BigInt!
  adminAddress: Bytes!
  staker: Staker!
  tokenFactory: TokenFactory!
  longShort: LongShortContract!
  totalFloatMinted: BigInt!
  totalTxs: BigInt!
  totalGasUsed: BigInt!
  totalUsers: BigInt!
  timestampLaunched: BigInt!
  txHash: Bytes!
}
