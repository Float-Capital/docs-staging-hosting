type EventParam @entity {
  id: ID!
  index: Int!
  param: String!
  paramName: String!
  paramType: String!
}

type EventParams @entity {
  id: ID!
  index: Int!
  eventName: String!
  params: [EventParam!]!
}

type StateChange @entity {
  id: ID! # tx
  timestamp: BigInt!
  blockNumber: BigInt!
  txEventParamList: [EventParams!]!
}

type Event @entity {
  id: ID!
  address: Bytes!
}

type SystemState @entity {
  id: ID! # marketIndex "-" callCounter
  timestamp: BigInt!
  txHash: Bytes!
  blockNumber: BigInt!
  marketIndex: BigInt!
  syntheticPrice: BigInt! # TODO: this should be a reference to another entity that holds the price
  longTokenPrice: BigInt!
  shortTokenPrice: BigInt!
  totalLockedLong: BigInt!
  totalLockedShort: BigInt!
  totalValueLocked: BigInt!
  setBy: Bytes! #Turn into a User entity
}

type FeeStructure @entity {
  id: ID!
  baseEntryFee: BigInt!
  badLiquidityEntryFee: BigInt!
  baseExitFee: BigInt!
  badLiquidityExitFee: BigInt!
}

type Transfer @entity {
  id: ID!
  from: String!
  to: String!
  value: BigInt!
}

enum TokenType {
  Long
  Short
}

type SyntheticToken @entity {
  id: ID! # token address
  tokenAddress: Bytes!
  syntheticMarket: SyntheticMarket!
  tokenType: TokenType!
  totalStaked: BigInt!
  floatMintedFromSpecificToken: BigInt!
}

type SyntheticMarket @entity {
  id: ID! # ID -> Market Index
  timestampCreated: BigInt!
  txHash: Bytes!
  blockNumberCreated: BigInt!
  name: String!
  symbol: String!
  marketIndex: BigInt!
  oracleAddress: Bytes!
  syntheticLong: SyntheticToken!
  syntheticShort: SyntheticToken!
  latestSystemState: SystemState!
  feeStructure: FeeStructure!
}

type User @entity {
  id: ID! # ID -> Public address
  address: Bytes!
  totalMintedFloat: BigInt!
}

type UserSyntheticTokenBalance @entity {
  id: ID! # ID ->
  syntheticToken: SyntheticToken!
  user: User!
  tokenBalance: BigInt!
}

type CurrentStake @entity {
  id: ID! # user address - fund address
  user: User!
  userAddress: Bytes!
  syntheticToken: SyntheticToken!
  currentStake: Stake!
  lastMintState: State!
}

type Stake @entity {
  id: ID! #"user address-fund address-txHashString"
  timestamp: BigInt!
  blockNumber: BigInt!
  creationTxHash: Bytes!
  syntheticToken: SyntheticToken!
  user: User!
  amount: BigInt!
  withdrawn: Boolean!
}

type State @entity {
  id: ID! # token address - state indexed
  blockNumber: BigInt!
  creationTxHash: Bytes!
  stateIndex: BigInt! #
  syntheticToken: SyntheticToken!
  timestamp: BigInt!
  accumulativeFloatPerSecond: BigInt!
}

type YieldManager @entity {
  id: ID!
  address: Bytes!
}

type OracleAggregator @entity {
  id: ID!
  address: Bytes!
}

type Staker @entity {
  id: ID!
  address: Bytes!
}

type TokenFactory @entity {
  id: ID!
  address: Bytes!
}

type LongShortContract @entity {
  id: ID!
  address: Bytes!
}

type GlobalState @entity {
  id: ID!
  contractVersion: BigInt!
  latestMarketIndex: BigInt!
  adminAddress: Bytes!
  staker: Staker!
  tokenFactory: TokenFactory!
  longShort: LongShortContract!
  totalFloatMinted: BigInt!
}
