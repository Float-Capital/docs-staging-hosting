type EventParam @entity {
  id: ID!
  index: Int!
  param: String!
  paramName: String!
  paramType: String!
}

type EventParams @entity {
  id: ID!
  index: Int!
  eventName: String!
  params: [EventParam!]!
}

type StateChange @entity {
  id: ID! # tx
  timestamp: BigInt!
  blockNumber: BigInt!
  txEventParamList: [EventParams!]!
}

type Event @entity {
  id: ID!
  address: Bytes!
}

# type FeesLevied @entity {
#   id: ID!
#   feeAmount: BigInt!
#   longFee: BigInt!
#   shortFee: BigInt!
# }

# type LongMint @entity {
#   id: ID!
#   user: Bytes!
# }

type SystemState @entity {
  id: ID! # marketIndex "-" callCounter
  timestamp: BigInt!
  txHash: Bytes!
  blockNumber: BigInt!
  marketIndex: BigInt!
  # syntheticMarket: SyntheticMarket!
  # previousSyntheticPrice: Price!
  syntheticPrice: BigInt! # TODO: this should be a reference to another entity that holds the price
  longTokenPrice: BigInt!
  shortTokenPrice: BigInt!
  totalLockedLong: BigInt!
  totalLockedShort: BigInt!
  totalValueLocked: BigInt!
  setBy: Bytes! #Turn into a User entity
}

type SyntheticMarket @entity {
  id: ID! # ID -> Market Index
  marketIndex: BigInt!
  totalValueLockedInMarket: BigInt!
  referenceAssetPrice: BigInt!
  oracleAddress: Bytes!
  syntheticLong: SyntheticToken!
  syntheticShort: SyntheticToken!
  latestSystemState: SystemState!
  feeStructure: FeeStructure!
}

type SyntheticToken @entity {
  id: ID! # token address
  tokenAddress: Bytes!
  tokenPrice: BigInt!
  tokenSupply: BigInt!
  totalValueLocked: BigInt!
}

type FeeStructure @entity {
  id: ID!
  baseEntryFee: Bytes!
  badLiquidityEntryFee: BigInt!
  baseExitFee: BigInt!
  badLiquidityExitFee: BigInt!
}

type GlobalState @entity {
  id: ID!
  latestSyntheticMarket: SyntheticMarket!
  # latestMarket:
}
