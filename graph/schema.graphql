type EventParam @entity {
  id: ID!
  index: Int!
  param: String!
  paramName: String!
  paramType: String!
}

type EventParams @entity {
  id: ID!
  index: Int!
  eventName: String!
  params: [EventParam!]!
}

type StateChange @entity {
  id: ID! # tx
  timestamp: BigInt!
  blockNumber: BigInt!
  gasUsed: BigInt!
  txEventParamList: [EventParams!]!
  affectedUsers: [User!]!
  affectedStakes: [CurrentStake!]!
}

type Event @entity {
  id: ID!
  address: Bytes!
}

type Price @entity {
  id: ID! # <marketIndex>-<long/short>-<timestamp>
  price: BigInt!
  timeUpdated: BigInt!
  token: SyntheticToken!
}

type LatestPrice @entity {
  id: ID! # latestPrice-<marketIndex>-<underlying>
  price: Price!
}

type UnderlyingPrice @entity {
  id: ID! # <marketIndex>-underlying-<timestamp>
  price: BigInt!
  timeUpdated: BigInt!
  market: SyntheticMarket!
}

type LatestUnderlyingPrice @entity {
  id: ID! # latestPrice-<marketIndex>-<underlying>
  price: UnderlyingPrice!
}

type NextBatchedNextPriceExec @entity {
  id: ID! # nextBatch-<marketIndex>
  nextBatch: BatchedNextPriceExec!
  currentUpdateIndex: BigInt!
}

type BatchedNextPriceExec @entity {
  id: ID! # batched-<marketIndex>-<update-index>
  updateIndex: BigInt!
  marketIndex: BigInt!
  amountPaymentTokenForDepositLong: BigInt!
  amountPaymentTokenForDepositShort: BigInt!
  amountSynthTokenForWithdrawalLong: BigInt!
  amountSynthTokenForWithdrawalShort: BigInt!
  mintPriceSnapshotLong: BigInt!
  mintPriceSnapshotShort: BigInt!
  redeemPriceSnapshotLong: BigInt!
  redeemPriceSnapshotShort: BigInt!
  executedTimestamp: BigInt!
  linkedUserNextPriceActions: [UserNextPriceAction!]!
}

# type AllUserNextPriceActionsInBatch @entity {
#   id: ID! # nextPrice-<marketIndex>-<update-index>
#   updateIndex: BigInt!
#   allUserActionsInBatch: [UserNextPriceAction!]!
# }

enum NextPriceAction {
  Mint
  Redeem
}
type UserNextPriceActionComponent @entity {
  id: ID! # actionComponent-<userAddress>-<marketIndex>-<update-index>-<type>-<index-of-type> // the index-of-type is for the case that multiple actions of the same type occur
  actionType: NextPriceAction!
  marketSide: MarketSide!
  amount: BigInt!
  user: User!
  updateIndex: BigInt!
  marketIndex: BigInt!
  timestamp: BigInt!
  userAggregateAction: UserNextPriceAction!
  associatedBatch: BatchedNextPriceExec!
}

type UsersCurrentNextPriceAction @entity {
  id: ID! # userCurrentAction-<marketIndex>-<userAddress>
  currentAction: UserNextPriceAction!
  currentUpdateIndex: BigInt!
}

type UserNextPriceAction @entity {
  id: ID! # nextPrice-<userAddress>-<marketIndex>-<update-index>
  updateIndex: BigInt!
  marketIndex: BigInt!
  user: User!
  amountPaymentTokenForDepositLong: BigInt!
  amountPaymentTokenForDepositShort: BigInt!
  amountSynthTokenForWithdrawalLong: BigInt!
  amountSynthTokenForWithdrawalShort: BigInt!
  nextPriceActionComponents: [UserNextPriceActionComponent!]!
  # These timestamps will be zero if the user action hasn't been confirmed/settled yet
  confirmedTimestamp: BigInt! # the timestamp the batched settlement occured
  settledTimestamp: BigInt! # timestamp the settlement happened on the blockchain for the user
  associatedBatch: BatchedNextPriceExec!
}

type SystemState @entity {
  id: ID! # marketIndex "-" callCounter
  timestamp: BigInt!
  txHash: Bytes!
  blockNumber: BigInt!
  marketIndex: BigInt!
  underlyingPrice: LatestUnderlyingPrice!
  longTokenPrice: LatestPrice!
  shortTokenPrice: LatestPrice!
  longToken: SyntheticToken!
  shortToken: SyntheticToken!
  totalLockedLong: BigInt!
  totalLockedShort: BigInt!
  totalValueLocked: BigInt!
  setBy: Bytes! #Turn into a User entity
}

interface GenericTransfer {
  id: ID!
  from: String!
  to: String!
  value: BigInt!
}

type Transfer implements GenericTransfer @entity {
  id: ID!
  from: String!
  to: String!
  value: BigInt!
  token: SyntheticToken!
}

type PaymentTokenTransfer implements GenericTransfer @entity {
  id: ID!
  from: String!
  to: String!
  value: BigInt!
  token: PaymentToken!
}

enum MarketSide {
  Long
  Short
}

type SyntheticToken @entity {
  id: ID! # token address
  tokenAddress: Bytes!
  syntheticMarket: SyntheticMarket!
  tokenType: MarketSide!
  totalStaked: BigInt!
  tokenSupply: BigInt!
  floatMintedFromSpecificToken: BigInt!
  latestPrice: LatestPrice!
  priceHistory: [Price!]!
}

type PaymentToken @entity {
  id: ID! # token address
  linkedMarkets: [SyntheticMarket!]!
}

type TokenApproval @entity {
  id: ID! # userAddress-tokenAddress
  paymentToken: PaymentToken!
  user: User!
  approvedInnacurate: BigInt!
  timestamp: BigInt!
}

type UserPaymentTokenApproval @entity {
  id: ID! # userAddress-tokenAddress
  approvalsHistory: [TokenApproval!]!
  updateTimestamp: BigInt!
  paymentToken: PaymentToken!
  currentApproval: TokenApproval!
}

type UserPaymentTokenBalance @entity {
  id: ID! # token address - user address - "balance"
  timeLastUpdated: BigInt!
  paymentToken: PaymentToken!
  user: User!
  balanceInaccurate: BigInt!
}

type SyntheticMarket @entity {
  id: ID! # ID -> Market Index
  timestampCreated: BigInt!
  txHash: Bytes!
  blockNumberCreated: BigInt!
  paymentToken: PaymentToken!
  name: String!
  symbol: String!
  marketIndex: BigInt!
  oracleAddress: Bytes!
  latestAccumulativeFloatIssuanceSnapshot: AccumulativeFloatIssuanceSnapshot!
  previousOracleAddresses: [Bytes!]!
  syntheticLong: SyntheticToken!
  syntheticShort: SyntheticToken!
  latestSystemState: SystemState!
  kPeriod: BigInt!
  kMultiplier: BigInt!
  totalFloatMinted: BigInt!
  nextPriceActions: [UserNextPriceAction!]!
  settledNextPriceActions: [UserNextPriceAction!]!
}

type User @entity {
  id: ID! # ID -> Public address
  address: Bytes!
  totalMintedFloat: BigInt!
  floatTokenBalance: BigInt!
  timestampJoined: BigInt!
  totalGasUsed: BigInt!
  numberOfTransactions: BigInt!
  currentStakes: [CurrentStake!]!
  stateChangesAffectingUser: [StateChange!]!
  tokenBalances: [UserSyntheticTokenBalance!]!
  collatoralBalances: [UserPaymentTokenBalance!]!
  tokenMints: [UserSyntheticTokenMinted!]!
  collatoralTokenApprovals: [UserPaymentTokenApproval!]!
  pendingNextPriceActions: [UserNextPriceAction!]!
  confirmedNextPriceActions: [UserNextPriceAction!]!
  settledNextPriceActions: [UserNextPriceAction!]!
}

type UserSyntheticTokenBalance @entity {
  id: ID! # token address - user address - "balance"
  timeLastUpdated: BigInt!
  syntheticToken: SyntheticToken!
  user: User!
  tokenBalance: BigInt!
}

type UserSyntheticTokenMinted @entity {
  id: ID! # token address - user address - "minted"
  syntheticToken: SyntheticToken!
  user: User!
  tokensMinted: BigInt!
}

type CurrentStake @entity {
  id: ID! # token address - user address - "currentStake"
  user: User!
  userAddress: Bytes!
  syntheticToken: SyntheticToken!
  syntheticMarket: SyntheticMarket!
  currentStake: Stake!
  lastMintState: AccumulativeFloatIssuanceSnapshot!
}

type Stake @entity {
  id: ID! # "txHashString"
  timestamp: BigInt!
  blockNumber: BigInt!
  creationTxHash: Bytes!
  syntheticToken: SyntheticToken!
  user: User!
  amount: BigInt!
  withdrawn: Boolean!
}

type AccumulativeFloatIssuanceSnapshot @entity {
  id: ID! # token address - state indexed
  index: BigInt! #
  blockNumber: BigInt!
  creationTxHash: Bytes!
  longToken: SyntheticToken!
  shortToken: SyntheticToken!
  timestamp: BigInt!
  accumulativeFloatPerTokenLong: BigInt!
  accumulativeFloatPerTokenShort: BigInt!
  floatRatePerTokenOverIntervalLong: BigInt!
  floatRatePerTokenOverIntervalShort: BigInt!
  timeSinceLastUpdate: BigInt!
}

type YieldManager @entity {
  id: ID!
  address: Bytes!
}

type OracleAggregator @entity {
  id: ID!
  address: Bytes!
}

type Staker @entity {
  id: ID!
  address: Bytes!
}

type TokenFactory @entity {
  id: ID!
  address: Bytes!
}

type LongShortContract @entity {
  id: ID!
  address: Bytes!
}

type GlobalState @entity {
  id: ID!
  contractVersion: BigInt!
  latestMarketIndex: BigInt!
  adminAddress: Bytes!
  staker: Staker!
  tokenFactory: TokenFactory!
  longShort: LongShortContract!
  totalFloatMinted: BigInt!
  totalTxs: BigInt!
  totalGasUsed: BigInt!
  totalUsers: BigInt!
  timestampLaunched: BigInt!
  txHash: Bytes!
}
