// Generated by Codegen.res, PLEASE EDIT WITH CARE

open ConverterTypes
  
@decco.decode
type transferData = {
  from: address,
  to: address,
  amount: bn,
}
@decco.decode
type approvalData = {
  owner: address,
  spender: address,
  value: bn,
}
@decco.decode
type accumulativeIssuancePerStakedSynthSnapshotCreatedData = {
  marketIndex: bn,
  accumulativeFloatIssuanceSnapshotIndex: bn,
  accumulativeLong: bn,
  accumulativeShort: bn,
}
@decco.decode
type systemStateUpdatedData = {
  marketIndex: bn,
  updateIndex: bn,
  underlyingAssetPrice: bn,
  longValue: bn,
  shortValue: bn,
  longPrice: bn,
  shortPrice: bn,
}
@decco.decode
type gemsCollectedData = {
  user: address,
  gems: bn,
  streak: bn,
}
@decco.decode
type nextPriceSyntheticPositionShiftData = {
  synthShifted: bn,
  marketIndex: bn,
  oracleUpdateIndex: bn,
  isShiftFromLong: @decco.codec(boolStringDeccoCodex) bool,
  user: address,
}
@decco.decode
type nextPriceStakeShiftData = {
  user: address,
  marketIndex: bn,
  amount: bn,
  isShiftFromLong: @decco.codec(boolStringDeccoCodex) bool,
  userShiftIndex: bn,
}
@decco.decode
type executeNextPriceSettlementsUserData = {
  marketIndex: bn,
  userAddress: address,
}
@decco.decode
type nextPriceDepositData = {
  depositAdded: bn,
  marketIndex: bn,
  oracleUpdateIndex: bn,
  isLong: @decco.codec(boolStringDeccoCodex) bool,
  user: address,
}
@decco.decode
type longShortV1Data = {
  admin: address,
  tokenFactory: address,
  staker: address,
}
@decco.decode
type stakerV1Data = {
  floatAddress: address,
  floatPercentage: bn,
}
@decco.decode
type syntheticMarketCreatedData = {
  marketIndex: bn,
  longTokenAddress: address,
  shortTokenAddress: address,
  paymentAddress: address,
  initialAssetPrice: bn,
  name: string,
  symbol: string,
  oracleAddress: address,
  yieldManagerAddress: address,
}
@decco.decode
type stakeAddedData = {
  user: address,
  tokenAddress: address,
  amount: bn,
  lastMintIndex: bn,
}
@decco.decode
type nextPriceRedeemData = {
  synthRedeemed: bn,
  marketIndex: bn,
  oracleUpdateIndex: bn,
  isLong: @decco.codec(boolStringDeccoCodex) bool,
  user: address,
}
@decco.decode
type marketAddedToStakerData = {
  marketIndex: bn,
  exitFee_e18: bn,
  balanceIncentiveExponent: bn,
  multiplier: bn,
  period: bn,
  balanceIncentiveEquilibriumOffset: bn,
}
@decco.decode
type newMarketLaunchedAndSeededData = {
  marketIndex: bn,
  initialMarketSeed: bn,
  marketLeverage: bn,
}

  type stateChanges =
  | Unclassified(unclassifiedEvent)
  | Transfer(transferData)
  | Approval(approvalData)
  | AccumulativeIssuancePerStakedSynthSnapshotCreated(accumulativeIssuancePerStakedSynthSnapshotCreatedData)
  | SystemStateUpdated(systemStateUpdatedData)
  | GemsCollected(gemsCollectedData)
  | NextPriceSyntheticPositionShift(nextPriceSyntheticPositionShiftData)
  | NextPriceStakeShift(nextPriceStakeShiftData)
  | ExecuteNextPriceSettlementsUser(executeNextPriceSettlementsUserData)
  | NextPriceDeposit(nextPriceDepositData)
  | LongShortV1(longShortV1Data)
  | StakerV1(stakerV1Data)
  | SyntheticMarketCreated(syntheticMarketCreatedData)
  | StakeAdded(stakeAddedData)
  | NextPriceRedeem(nextPriceRedeemData)
  | MarketAddedToStaker(marketAddedToStakerData)
  | NewMarketLaunchedAndSeeded(newMarketLaunchedAndSeededData)

  let covertToStateChange = (eventName, paramsObject) => {
  // TODO: throw a (descriptive) error if the array of parameters are wrong somehow (or make a separate test?)
  switch eventName {
  | "Transfer" => Transfer(paramsObject->Js.Json.object_->transferData_decode->Result.getExn)
  | "Approval" => Approval(paramsObject->Js.Json.object_->approvalData_decode->Result.getExn)
  | "AccumulativeIssuancePerStakedSynthSnapshotCreated" => AccumulativeIssuancePerStakedSynthSnapshotCreated(paramsObject->Js.Json.object_->accumulativeIssuancePerStakedSynthSnapshotCreatedData_decode->Result.getExn)
  | "SystemStateUpdated" => SystemStateUpdated(paramsObject->Js.Json.object_->systemStateUpdatedData_decode->Result.getExn)
  | "GemsCollected" => GemsCollected(paramsObject->Js.Json.object_->gemsCollectedData_decode->Result.getExn)
  | "NextPriceSyntheticPositionShift" => NextPriceSyntheticPositionShift(paramsObject->Js.Json.object_->nextPriceSyntheticPositionShiftData_decode->Result.getExn)
  | "NextPriceStakeShift" => NextPriceStakeShift(paramsObject->Js.Json.object_->nextPriceStakeShiftData_decode->Result.getExn)
  | "ExecuteNextPriceSettlementsUser" => ExecuteNextPriceSettlementsUser(paramsObject->Js.Json.object_->executeNextPriceSettlementsUserData_decode->Result.getExn)
  | "NextPriceDeposit" => NextPriceDeposit(paramsObject->Js.Json.object_->nextPriceDepositData_decode->Result.getExn)
  | "LongShortV1" => LongShortV1(paramsObject->Js.Json.object_->longShortV1Data_decode->Result.getExn)
  | "StakerV1" => StakerV1(paramsObject->Js.Json.object_->stakerV1Data_decode->Result.getExn)
  | "SyntheticMarketCreated" => SyntheticMarketCreated(paramsObject->Js.Json.object_->syntheticMarketCreatedData_decode->Result.getExn)
  | "StakeAdded" => StakeAdded(paramsObject->Js.Json.object_->stakeAddedData_decode->Result.getExn)
  | "NextPriceRedeem" => NextPriceRedeem(paramsObject->Js.Json.object_->nextPriceRedeemData_decode->Result.getExn)
  | "MarketAddedToStaker" => MarketAddedToStaker(paramsObject->Js.Json.object_->marketAddedToStakerData_decode->Result.getExn)
  | "NewMarketLaunchedAndSeeded" => NewMarketLaunchedAndSeeded(paramsObject->Js.Json.object_->newMarketLaunchedAndSeededData_decode->Result.getExn)
    | name => Unclassified({name: name, data: paramsObject})
  }
}

  type eventGroup = {
  allTransferEvents: array<eventData<transferData>>,
  allApprovalEvents: array<eventData<approvalData>>,
  allAccumulativeIssuancePerStakedSynthSnapshotCreatedEvents: array<eventData<accumulativeIssuancePerStakedSynthSnapshotCreatedData>>,
  allSystemStateUpdatedEvents: array<eventData<systemStateUpdatedData>>,
  allGemsCollectedEvents: array<eventData<gemsCollectedData>>,
  allNextPriceSyntheticPositionShiftEvents: array<eventData<nextPriceSyntheticPositionShiftData>>,
  allNextPriceStakeShiftEvents: array<eventData<nextPriceStakeShiftData>>,
  allExecuteNextPriceSettlementsUserEvents: array<eventData<executeNextPriceSettlementsUserData>>,
  allNextPriceDepositEvents: array<eventData<nextPriceDepositData>>,
  allLongShortV1Events: array<eventData<longShortV1Data>>,
  allStakerV1Events: array<eventData<stakerV1Data>>,
  allSyntheticMarketCreatedEvents: array<eventData<syntheticMarketCreatedData>>,
  allStakeAddedEvents: array<eventData<stakeAddedData>>,
  allNextPriceRedeemEvents: array<eventData<nextPriceRedeemData>>,
  allMarketAddedToStakerEvents: array<eventData<marketAddedToStakerData>>,
  allNewMarketLaunchedAndSeededEvents: array<eventData<newMarketLaunchedAndSeededData>>,
    allUnclassifiedEvents: array<ConverterTypes.unclassifiedEvent>,
  }
  let emptyEventGroups = {
  allTransferEvents: [],
  allApprovalEvents: [],
  allAccumulativeIssuancePerStakedSynthSnapshotCreatedEvents: [],
  allSystemStateUpdatedEvents: [],
  allGemsCollectedEvents: [],
  allNextPriceSyntheticPositionShiftEvents: [],
  allNextPriceStakeShiftEvents: [],
  allExecuteNextPriceSettlementsUserEvents: [],
  allNextPriceDepositEvents: [],
  allLongShortV1Events: [],
  allStakerV1Events: [],
  allSyntheticMarketCreatedEvents: [],
  allStakeAddedEvents: [],
  allNextPriceRedeemEvents: [],
  allMarketAddedToStakerEvents: [],
  allNewMarketLaunchedAndSeededEvents: [],
    allUnclassifiedEvents: [],
  }

  let addEventToCorrectGrouping = (
    currentEventGroups,
    {ConverterTypes.blockNumber: blockNumber, timestamp, txHash, data},
  ) => {
    switch data {
  | Transfer(eventData) => {
      ...currentEventGroups,
      allTransferEvents: currentEventGroups.allTransferEvents->Array.concat([
        {blockNumber: blockNumber, timestamp: timestamp, data: eventData, txHash: txHash},
      ]),
    }
  | Approval(eventData) => {
      ...currentEventGroups,
      allApprovalEvents: currentEventGroups.allApprovalEvents->Array.concat([
        {blockNumber: blockNumber, timestamp: timestamp, data: eventData, txHash: txHash},
      ]),
    }
  | AccumulativeIssuancePerStakedSynthSnapshotCreated(eventData) => {
      ...currentEventGroups,
      allAccumulativeIssuancePerStakedSynthSnapshotCreatedEvents: currentEventGroups.allAccumulativeIssuancePerStakedSynthSnapshotCreatedEvents->Array.concat([
        {blockNumber: blockNumber, timestamp: timestamp, data: eventData, txHash: txHash},
      ]),
    }
  | SystemStateUpdated(eventData) => {
      ...currentEventGroups,
      allSystemStateUpdatedEvents: currentEventGroups.allSystemStateUpdatedEvents->Array.concat([
        {blockNumber: blockNumber, timestamp: timestamp, data: eventData, txHash: txHash},
      ]),
    }
  | GemsCollected(eventData) => {
      ...currentEventGroups,
      allGemsCollectedEvents: currentEventGroups.allGemsCollectedEvents->Array.concat([
        {blockNumber: blockNumber, timestamp: timestamp, data: eventData, txHash: txHash},
      ]),
    }
  | NextPriceSyntheticPositionShift(eventData) => {
      ...currentEventGroups,
      allNextPriceSyntheticPositionShiftEvents: currentEventGroups.allNextPriceSyntheticPositionShiftEvents->Array.concat([
        {blockNumber: blockNumber, timestamp: timestamp, data: eventData, txHash: txHash},
      ]),
    }
  | NextPriceStakeShift(eventData) => {
      ...currentEventGroups,
      allNextPriceStakeShiftEvents: currentEventGroups.allNextPriceStakeShiftEvents->Array.concat([
        {blockNumber: blockNumber, timestamp: timestamp, data: eventData, txHash: txHash},
      ]),
    }
  | ExecuteNextPriceSettlementsUser(eventData) => {
      ...currentEventGroups,
      allExecuteNextPriceSettlementsUserEvents: currentEventGroups.allExecuteNextPriceSettlementsUserEvents->Array.concat([
        {blockNumber: blockNumber, timestamp: timestamp, data: eventData, txHash: txHash},
      ]),
    }
  | NextPriceDeposit(eventData) => {
      ...currentEventGroups,
      allNextPriceDepositEvents: currentEventGroups.allNextPriceDepositEvents->Array.concat([
        {blockNumber: blockNumber, timestamp: timestamp, data: eventData, txHash: txHash},
      ]),
    }
  | LongShortV1(eventData) => {
      ...currentEventGroups,
      allLongShortV1Events: currentEventGroups.allLongShortV1Events->Array.concat([
        {blockNumber: blockNumber, timestamp: timestamp, data: eventData, txHash: txHash},
      ]),
    }
  | StakerV1(eventData) => {
      ...currentEventGroups,
      allStakerV1Events: currentEventGroups.allStakerV1Events->Array.concat([
        {blockNumber: blockNumber, timestamp: timestamp, data: eventData, txHash: txHash},
      ]),
    }
  | SyntheticMarketCreated(eventData) => {
      ...currentEventGroups,
      allSyntheticMarketCreatedEvents: currentEventGroups.allSyntheticMarketCreatedEvents->Array.concat([
        {blockNumber: blockNumber, timestamp: timestamp, data: eventData, txHash: txHash},
      ]),
    }
  | StakeAdded(eventData) => {
      ...currentEventGroups,
      allStakeAddedEvents: currentEventGroups.allStakeAddedEvents->Array.concat([
        {blockNumber: blockNumber, timestamp: timestamp, data: eventData, txHash: txHash},
      ]),
    }
  | NextPriceRedeem(eventData) => {
      ...currentEventGroups,
      allNextPriceRedeemEvents: currentEventGroups.allNextPriceRedeemEvents->Array.concat([
        {blockNumber: blockNumber, timestamp: timestamp, data: eventData, txHash: txHash},
      ]),
    }
  | MarketAddedToStaker(eventData) => {
      ...currentEventGroups,
      allMarketAddedToStakerEvents: currentEventGroups.allMarketAddedToStakerEvents->Array.concat([
        {blockNumber: blockNumber, timestamp: timestamp, data: eventData, txHash: txHash},
      ]),
    }
  | NewMarketLaunchedAndSeeded(eventData) => {
      ...currentEventGroups,
      allNewMarketLaunchedAndSeededEvents: currentEventGroups.allNewMarketLaunchedAndSeededEvents->Array.concat([
        {blockNumber: blockNumber, timestamp: timestamp, data: eventData, txHash: txHash},
      ]),
    }
    | Unclassified(event) => {
        ...currentEventGroups,
        allUnclassifiedEvents: currentEventGroups.allUnclassifiedEvents->Array.concat([event]),
      }
    }
  }
  