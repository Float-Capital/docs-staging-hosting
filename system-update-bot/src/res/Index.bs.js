// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Config = require("./library/Config.bs.js");
var Ethers = require("./library/Ethers.bs.js");
var Ethers$1 = require("ethers");
var Contracts = require("./library/Contracts.bs.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");

function getAggregatorAddresses(chainlinkOracleAddresses, wallet) {
  var signer = Ethers.getSigner(wallet);
  return Promise.all(Belt_Array.map(chainlinkOracleAddresses, (function (address) {
                    var oracle = Contracts.Oracle.make(address, signer);
                    return oracle.phaseId().then(function (id) {
                                return oracle.phaseAggregators(id);
                              });
                  })));
}

function mapWalletBalance(wallet, fn) {
  return wallet.getBalance().then(Curry.__1(fn));
}

function getJsonProviders(providerUrls) {
  return Promise.all(Belt_Array.map(providerUrls, (function (url) {
                    return new (Ethers$1.providers.JsonRpcProvider)(url, 80001);
                  })));
}

function getProvider(urls) {
  return getJsonProviders(urls).then(function (providers) {
              return new (Ethers$1.providers.FallbackProvider)(providers, 1);
            });
}

var defaultOptions = {
  gasPrice: 1000000000
};

var wallet = {
  contents: undefined
};

var provider = {
  contents: undefined
};

var updateCounter = {
  contents: 0
};

function runUpdateSystemStateMulti(param) {
  updateCounter.contents = updateCounter.contents + 1 | 0;
  console.log("running update", updateCounter.contents);
  var balanceBefore = {
    contents: undefined
  };
  return mapWalletBalance(wallet.contents, (function (balance) {
                    balanceBefore.contents = balance;
                    console.log("Matic balance pre contract call: ", Ethers.Utils.formatEther(balance));
                    
                  })).then(function (param) {
                var contract = Contracts.LongShort.make(Config.config.longShortContractAddress, Ethers.getSigner(wallet.contents));
                return contract.functions.updateSystemStateMulti([
                                  1,
                                  2,
                                  3
                                ], defaultOptions).then(function (update) {
                                console.log("submitted transaction", update.hash);
                                return update.wait();
                              }).then(function (param) {
                              return function (param) {
                                console.log("Transaction processes", param);
                                
                              };
                            }).catch(function (e) {
                            console.log("ERROR");
                            console.log("-------------------");
                            console.log(e);
                            
                          });
              }).then(function (param) {
              return mapWalletBalance(wallet.contents, (function (balance) {
                            console.log("Matic balance post contract call:", Ethers.Utils.formatEther(balance), "gas used", Ethers.Utils.formatEther(balanceBefore.contents.sub(balance)));
                            
                          }));
            });
}

function setup(param) {
  return Promise.all([
                    getProvider(Config.secrets.providerUrls),
                    new (Ethers$1.Wallet.fromMnemonic)(Config.secrets.mnemonic)
                  ]).then(function (param) {
                  var _provider = param[0];
                  provider.contents = _provider;
                  wallet.contents = param[1].connect(_provider);
                  console.log("Initial update system state");
                  return runUpdateSystemStateMulti(undefined);
                }).then(function (param) {
                console.log("-------------------------");
                console.log("Getting aggregator addresses");
                return getAggregatorAddresses(Config.config.chainlinkOracleAddresses, wallet.contents);
              }).then(function (aggregatorAddresses) {
              Belt_Array.forEachWithIndex(aggregatorAddresses, (function (index, address) {
                      var filter_topics = [Ethers$1.utils.id("AnswerUpdated(int256,uint256,uint256)")];
                      var filter = {
                        address: address,
                        topics: filter_topics
                      };
                      provider.contents.on(filter, (function (param) {
                              console.log("Price updated for oracle " + Ethers.ethAdrToStr(Config.config.chainlinkOracleAddresses[index]));
                              runUpdateSystemStateMulti(undefined);
                              
                            }));
                      
                    }));
              console.log("Listening for new answers.");
              
            });
}

setup(undefined);

var config = Config.config;

var secrets = Config.secrets;

exports.config = config;
exports.secrets = secrets;
exports.getAggregatorAddresses = getAggregatorAddresses;
exports.mapWalletBalance = mapWalletBalance;
exports.getJsonProviders = getJsonProviders;
exports.getProvider = getProvider;
exports.defaultOptions = defaultOptions;
exports.wallet = wallet;
exports.provider = provider;
exports.updateCounter = updateCounter;
exports.runUpdateSystemStateMulti = runUpdateSystemStateMulti;
exports.setup = setup;
/*  Not a pure module */
