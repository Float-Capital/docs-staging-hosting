// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Mint = require("../../pages/Mint.js");
var Next = require("../../bindings/Next.js");
var Curry = require("rescript/lib/js/curry.js");
var React = require("react");
var Button = require("../UI/Base/Button.js");
var Ethers = require("../../ethereum/Ethers.js");
var Loader = require("../UI/Base/Loader.js");
var Redeem = require("../Redeem/Redeem.js");
var Backend = require("../../mockBackend/Backend.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Queries = require("../../data/Queries.js");
var Unstake = require("../Unstake.js");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var CONSTANTS = require("../../CONSTANTS.js");
var DataHooks = require("../../data/DataHooks.js");
var StakeForm = require("../Stake/StakeForm.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Router = require("next/router");
var RootProvider = require("../../libraries/RootProvider.js");
var ContractActions = require("../../ethereum/ContractActions.js");
var LongOrShortSelect = require("../UI/LongOrShortSelect.js");
var StakeTxStatusModal = require("../Stake/StakeTxStatusModal.js");
var WithdrawTxStatusModal = require("../Withdraw/WithdrawTxStatusModal.js");
var RedeemSubmitButtonAndTxStatusModal = require("../Redeem/RedeemSubmitButtonAndTxStatusModal.js");

function MarketInteractionCard$Tab(Props) {
  var selectedOpt = Props.selected;
  var text = Props.text;
  var onClickOpt = Props.onClick;
  var selected = selectedOpt !== undefined ? selectedOpt : false;
  var onClick = onClickOpt !== undefined ? onClickOpt : (function (param) {
        
      });
  var bg = selected ? "bg-white" : "bg-gray-100";
  var opacity = selected ? "bg-opacity-70" : "opacity-70";
  var margin = selected ? "pb-1.5" : "mb-0.5";
  return React.createElement("li", {
              className: "mr-1 md:mr-2 mb-0"
            }, React.createElement("div", {
                  className: bg + "  " + opacity + "  " + margin + " cursor-pointer inline-block rounded-t-lg py-1 px-4",
                  onClick: onClick
                }, text));
}

var Tab = {
  make: MarketInteractionCard$Tab
};

function onlyIfAllSomeWithDefault4(list, $$default, fn) {
  var a = list[0];
  if (a === undefined) {
    return $$default;
  }
  var b = list[1];
  if (b !== undefined) {
    var c = list[2];
    if (c !== undefined) {
      var d = list[3];
      if (d !== undefined) {
        return Curry._4(fn, Caml_option.valFromOption(a), Caml_option.valFromOption(b), Caml_option.valFromOption(c), Caml_option.valFromOption(d));
      }
      
    }
    
  }
  return $$default;
}

function onlyIfAllSomeWithDefault3(list, $$default, fn) {
  var a = list[0];
  if (a === undefined) {
    return $$default;
  }
  var b = list[1];
  if (b === undefined) {
    return $$default;
  }
  var c = list[2];
  if (c !== undefined) {
    return Curry._3(fn, Caml_option.valFromOption(a), Caml_option.valFromOption(b), Caml_option.valFromOption(c));
  } else {
    return $$default;
  }
}

function optAddressWithDefaultZero(optAddress) {
  return Belt_Option.getWithDefault(optAddress, CONSTANTS.zeroAddress);
}

var allTabs = [
  /* Mint */0,
  /* Redeem */1,
  /* Stake */2,
  /* Unstake */3
];

function tabToStr(tab) {
  switch (tab) {
    case /* Mint */0 :
        return "Mint";
    case /* Redeem */1 :
        return "Redeem";
    case /* Stake */2 :
        return "Stake";
    case /* Unstake */3 :
        return "Unstake";
    
  }
}

function strToTab(tab) {
  var match = tab.toLowerCase();
  switch (match) {
    case "mint" :
        return /* Mint */0;
    case "redeem" :
        return /* Redeem */1;
    case "stake" :
        return /* Stake */2;
    case "unstake" :
        return /* Unstake */3;
    default:
      return /* Mint */0;
  }
}

function useUserHasBalances(user, marketInfo) {
  var userOrZeroAddress = Belt_Option.getWithDefault(user, CONSTANTS.zeroAddress);
  var match = Belt_Option.mapWithDefault(marketInfo, [
        CONSTANTS.zeroAddress,
        CONSTANTS.zeroAddress
      ], (function (param) {
          return [
                  param.longAddress,
                  param.shortAddress
                ];
        }));
  var hasLongBalance = DataHooks.Util.graphResponseToOption(DataHooks.useSyntheticTokenBalanceOrZero(userOrZeroAddress, match[0]));
  var hasShortBalance = DataHooks.Util.graphResponseToOption(DataHooks.useSyntheticTokenBalanceOrZero(userOrZeroAddress, match[1]));
  return onlyIfAllSomeWithDefault4([
              user,
              marketInfo,
              hasShortBalance,
              hasLongBalance
            ], undefined, (function (param, param$1, shortBalance, longBalance) {
                return {
                        hasLong: longBalance.gt(CONSTANTS.zeroBN),
                        hasShort: shortBalance.gt(CONSTANTS.zeroBN)
                      };
              }));
}

function useUserHasStakes(user, marketInfo) {
  var userOrZeroAddress = Belt_Option.getWithDefault(user, CONSTANTS.zeroAddress);
  var userStakes = DataHooks.Util.graphResponseToOption(DataHooks.useStakesForUser(Ethers.Utils.ethAdrToLowerStr(userOrZeroAddress)));
  return onlyIfAllSomeWithDefault3([
              user,
              marketInfo,
              userStakes
            ], undefined, (function (param, marketInfo, stakes) {
                return Belt_Array.reduce(stakes, {
                            hasLong: false,
                            hasShort: false
                          }, (function (previousAnswer, param) {
                              var tokenAddress = param.currentStake.syntheticToken.tokenAddress;
                              return {
                                      hasLong: previousAnswer.hasLong || Caml_obj.caml_equal(tokenAddress, marketInfo.longAddress),
                                      hasShort: previousAnswer.hasShort || Caml_obj.caml_equal(tokenAddress, marketInfo.shortAddress)
                                    };
                            }));
              }));
}

function useMarketInfo(param) {
  var markets = Curry.app(Queries.MarketDetails.use, [
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined
      ]);
  var router = Router.useRouter();
  var marketIndex = Belt_Option.getWithDefault(Js_dict.get(router.query, "marketIndex"), "1");
  var response = DataHooks.Util.queryToResponse(markets);
  if (typeof response === "number") {
    return /* Loading */0;
  }
  if (response.TAG === /* GraphError */0) {
    return {
            TAG: 0,
            _0: response._0,
            [Symbol.for("name")]: "GraphError"
          };
  }
  var optFirstMarket = Belt_Array.get(response._0.syntheticMarkets, Belt_Option.getWithDefault(Belt_Int.fromString(marketIndex), 1) - 1 | 0);
  return Belt_Option.mapWithDefault(optFirstMarket, {
              TAG: 0,
              _0: "Market doesn't exist",
              [Symbol.for("name")]: "GraphError"
            }, (function (market) {
                var match = market.syntheticShort;
                var match$1 = market.syntheticLong;
                return {
                        TAG: 1,
                        _0: {
                          longId: match$1.id,
                          shortId: match.id,
                          marketName: market.name,
                          marketSymbol: market.symbol,
                          longAddress: match$1.tokenAddress,
                          shortAddress: match.tokenAddress,
                          marketIndex: market.marketIndex
                        },
                        [Symbol.for("name")]: "Response"
                      };
              }));
}

function header(marketInfo) {
  if (typeof marketInfo === "number") {
    return null;
  }
  if (marketInfo.TAG === /* GraphError */0) {
    return null;
  }
  var match = marketInfo._0;
  return React.createElement("div", {
              className: "flex justify-between mb-2 pt-6 pl-6"
            }, Backend.getMarketInfoUnsafe(match.marketIndex.toNumber()).name + " (" + match.marketSymbol + ")");
}

function MarketInteractionCard$SelectOptions(Props) {
  var isLong = Props.isLong;
  var marketInfo = Props.marketInfo;
  var disabledOpt = Props.disabled;
  var disabled = disabledOpt !== undefined ? disabledOpt : false;
  var router = Router.useRouter();
  return Belt_Option.mapWithDefault(marketInfo, null, (function (marketInfo) {
                return React.createElement("div", {
                            className: "px-6"
                          }, React.createElement(LongOrShortSelect.make, {
                                isLong: isLong,
                                selectPosition: (function (val) {
                                    router.query["actionOption"] = val;
                                    router.query["token"] = isLong ? Ethers.Utils.ethAdrToLowerStr(marketInfo.longAddress) : Ethers.Utils.ethAdrToLowerStr(marketInfo.shortAddress);
                                    return Next.Router.pushObjShallow(router, {
                                                pathname: router.pathname,
                                                query: router.query
                                              });
                                  }),
                                disabled: disabled
                              }));
              }));
}

var SelectOptions = {
  make: MarketInteractionCard$SelectOptions
};

function wrapper(children) {
  return React.createElement("div", {
              className: "pb-6 px-6"
            }, children);
}

function MarketInteractionCard$NoBalancesView(Props) {
  var interactionOpt = Props.interaction;
  var text = Props.text;
  var buttonTextOpt = Props.buttonText;
  var interaction = interactionOpt !== undefined ? interactionOpt : (function (param) {
        
      });
  var buttonText = buttonTextOpt !== undefined ? buttonTextOpt : "";
  return React.createElement(React.Fragment, undefined, React.createElement("div", {
                  className: "py-4 mx-auto flex flex-col items-center"
                }, text, React.createElement("div", {
                      className: "py-2 w-24"
                    }, React.createElement(Button.Small.make, {
                          onClick: interaction,
                          children: buttonText
                        }))));
}

var NoBalancesView = {
  make: MarketInteractionCard$NoBalancesView
};

function determineDisplay(user, userHasPositions, isLong, marketInfo) {
  if (user === undefined) {
    return /* Default */1;
  }
  if (typeof marketInfo === "number") {
    return /* Loading */0;
  }
  if (marketInfo.TAG === /* GraphError */0) {
    return {
            TAG: 1,
            _0: marketInfo._0,
            [Symbol.for("name")]: "Error"
          };
  }
  var match = marketInfo._0;
  var marketIndex = match.marketIndex;
  var shortId = match.shortId;
  var longId = match.longId;
  var tokenName = (
    isLong ? "Long" : "Short"
  ) + " " + match.marketName;
  var chosenTokenId = isLong ? longId : shortId;
  if (userHasPositions !== undefined) {
    if (userHasPositions.hasLong) {
      if (userHasPositions.hasShort) {
        return {
                TAG: 0,
                selectOptions: /* Show */0,
                tokenId: chosenTokenId,
                tokenName: tokenName,
                marketIndex: marketIndex,
                [Symbol.for("name")]: "Form"
              };
      } else {
        return {
                TAG: 0,
                selectOptions: /* DontShow */1,
                tokenId: longId,
                tokenName: tokenName,
                marketIndex: marketIndex,
                [Symbol.for("name")]: "Form"
              };
      }
    } else if (userHasPositions.hasShort) {
      return {
              TAG: 0,
              selectOptions: /* DontShow */1,
              tokenId: shortId,
              tokenName: tokenName,
              marketIndex: marketIndex,
              [Symbol.for("name")]: "Form"
            };
    } else {
      return /* Default */1;
    }
  } else {
    return /* Loading */0;
  }
}

function MarketInteractionCard$UnstakeInteractionWrapper(Props) {
  var isLong = Props.isLong;
  var marketInfo = Props.marketInfo;
  var user = Props.user;
  var userHasPositions = Props.userHasPositions;
  var form = Props.form;
  var $$default = Props.default;
  var signer = ContractActions.useSigner(undefined);
  var match = ContractActions.useContractFunction(Belt_Option.getWithDefault(signer, undefined));
  var txState = match[1];
  var optMarketInfo = DataHooks.Util.graphResponseToOption(marketInfo);
  var display = determineDisplay(user, userHasPositions, isLong, marketInfo);
  Unstake.useUnstakeModal(txState);
  if (typeof display === "number") {
    if (display === /* Loading */0) {
      return React.createElement(Loader.Mini.make, {});
    } else {
      return $$default;
    }
  } else if (display.TAG === /* Form */0) {
    return React.createElement(React.Fragment, undefined, display.selectOptions ? null : React.createElement(MarketInteractionCard$SelectOptions, {
                      isLong: isLong,
                      marketInfo: optMarketInfo
                    }), wrapper(React.createElement(form, {
                        tokenId: display.tokenId,
                        txState: txState,
                        setTxState: match[2],
                        contractExecutionHandler: match[0]
                      })));
  } else {
    return React.createElement("div", {
                className: "p-6"
              }, display._0);
  }
}

var UnstakeInteractionWrapper = {
  make: MarketInteractionCard$UnstakeInteractionWrapper
};

function MarketInteractionCard$StakeInteractionWrapper(Props) {
  var isLong = Props.isLong;
  var marketInfo = Props.marketInfo;
  var user = Props.user;
  var userHasPositions = Props.userHasPositions;
  var form = Props.form;
  var $$default = Props.default;
  var signer = ContractActions.useSigner(undefined);
  var match = ContractActions.useContractFunction(Belt_Option.getWithDefault(signer, undefined));
  var txState = match[1];
  var optMarketInfo = DataHooks.Util.graphResponseToOption(marketInfo);
  var display = determineDisplay(user, userHasPositions, isLong, marketInfo);
  var tmp;
  tmp = typeof display === "number" || display.TAG !== /* Form */0 ? "" : display.tokenName;
  StakeTxStatusModal.useStakeTxModal(txState, tmp);
  if (typeof display === "number") {
    if (display === /* Loading */0) {
      return React.createElement(Loader.Mini.make, {});
    } else {
      return $$default;
    }
  } else if (display.TAG === /* Form */0) {
    return React.createElement(React.Fragment, undefined, display.selectOptions ? null : React.createElement(MarketInteractionCard$SelectOptions, {
                      isLong: isLong,
                      marketInfo: optMarketInfo
                    }), wrapper(React.createElement(form, {
                        tokenId: display.tokenId,
                        txState: txState,
                        setTxState: match[2],
                        contractExecutionHandler: match[0]
                      })));
  } else {
    return React.createElement("div", {
                className: "p-6"
              }, display._0);
  }
}

var StakeInteractionWrapper = {
  make: MarketInteractionCard$StakeInteractionWrapper
};

function MarketInteractionCard$RedeemInteractionWrapper(Props) {
  var marketInfo = Props.marketInfo;
  var userHasBalances = Props.userHasBalances;
  var user = Props.user;
  var longSelected = Props.longSelected;
  var setSelected = Props.setSelected;
  var signerOpt = ContractActions.useSigner(undefined);
  var signer = Belt_Option.getWithDefault(signerOpt, undefined);
  var display = determineDisplay(user, userHasBalances, longSelected, marketInfo);
  var match = ContractActions.useContractFunction(signer);
  var txState = match[1];
  var match$1 = ContractActions.useContractFunction(signer);
  var txStateWithdraw = match$1[1];
  WithdrawTxStatusModal.useWithdrawTxModal(txStateWithdraw);
  var tmp;
  tmp = typeof marketInfo === "number" || marketInfo.TAG === /* GraphError */0 ? CONSTANTS.oneBN : marketInfo._0.marketIndex;
  RedeemSubmitButtonAndTxStatusModal.useRedeemModal(txState, tmp, txStateWithdraw, match$1[0]);
  if (display !== /* Default */1) {
    return wrapper(React.createElement(Redeem.make, {
                    txState: txState,
                    setTxState: match[2],
                    contractExecutionHandler: match[0]
                  }));
  } else {
    return React.createElement(MarketInteractionCard$NoBalancesView, {
                interaction: (function (param) {
                    return Curry._1(setSelected, (function (param) {
                                  return /* Mint */0;
                                }));
                  }),
                text: "No tokens for this market.",
                buttonText: "Mint"
              });
  }
}

var RedeemInteractionWrapper = {
  make: MarketInteractionCard$RedeemInteractionWrapper
};

function MarketInteractionCard(Props) {
  var router = Router.useRouter();
  var user = RootProvider.useCurrentUser(undefined);
  var selectedTab = Belt_Option.getWithDefault(Js_dict.get(router.query, "tab"), "Mint");
  var match = React.useState(function () {
        return strToTab(selectedTab);
      });
  var setSelected = match[1];
  var selected = match[0];
  var actionOption = Belt_Option.getWithDefault(Js_dict.get(router.query, "actionOption"), "short");
  var longSelected = actionOption.toLowerCase() === "long";
  var marketInfo = useMarketInfo(undefined);
  var userHasBalances = useUserHasBalances(user, DataHooks.Util.graphResponseToOption(marketInfo));
  var userHasStakes = useUserHasStakes(user, DataHooks.Util.graphResponseToOption(marketInfo));
  var tmp;
  switch (selected) {
    case /* Mint */0 :
        tmp = React.createElement(Mint.make, {
              withHeader: false
            });
        break;
    case /* Redeem */1 :
        tmp = React.createElement(MarketInteractionCard$RedeemInteractionWrapper, {
              marketInfo: marketInfo,
              userHasBalances: userHasBalances,
              user: user,
              longSelected: longSelected,
              setSelected: setSelected
            });
        break;
    case /* Stake */2 :
        tmp = React.createElement(MarketInteractionCard$StakeInteractionWrapper, {
              isLong: longSelected,
              marketInfo: marketInfo,
              user: user,
              userHasPositions: userHasBalances,
              form: StakeForm.make,
              default: React.createElement(MarketInteractionCard$NoBalancesView, {
                    interaction: (function (param) {
                        return Curry._1(setSelected, (function (param) {
                                      return /* Mint */0;
                                    }));
                      }),
                    text: "No tokens for this market.",
                    buttonText: "Mint"
                  }),
              key: "stake"
            });
        break;
    case /* Unstake */3 :
        var userHasNoStakesAndNoBalances = user !== undefined && !(userHasBalances !== undefined && !(userHasBalances.hasLong || userHasBalances.hasShort)) ? false : true;
        tmp = React.createElement(MarketInteractionCard$UnstakeInteractionWrapper, {
              isLong: longSelected,
              marketInfo: marketInfo,
              user: user,
              userHasPositions: userHasStakes,
              form: Unstake.make,
              default: React.createElement(MarketInteractionCard$NoBalancesView, {
                    interaction: (function (param) {
                        if (userHasNoStakesAndNoBalances) {
                          return Curry._1(setSelected, (function (param) {
                                        return /* Mint */0;
                                      }));
                        } else {
                          return Curry._1(setSelected, (function (param) {
                                        return /* Stake */2;
                                      }));
                        }
                      }),
                    text: userHasNoStakesAndNoBalances ? "No tokens or stakes for this market." : "No stakes for this market.",
                    buttonText: userHasNoStakesAndNoBalances ? "MINT" : "STAKE"
                  }),
              key: "unstake"
            });
        break;
    
  }
  return React.createElement("div", {
              className: "flex-1"
            }, React.createElement("ul", {
                  className: "list-reset flex items-end"
                }, Belt_Array.map(allTabs, (function (tab) {
                        return React.createElement(MarketInteractionCard$Tab, {
                                    selected: tab === selected,
                                    text: tabToStr(tab),
                                    onClick: (function (param) {
                                        Curry._1(setSelected, (function (param) {
                                                return tab;
                                              }));
                                        router.query["tab"] = tabToStr(tab).toLowerCase();
                                        return Next.Router.pushObjShallow(router, {
                                                    pathname: router.pathname,
                                                    query: router.query
                                                  });
                                      }),
                                    key: tabToStr(tab)
                                  });
                      }))), React.createElement("div", {
                  className: "rounded-b-lg min-h-market-interaction-card rounded-r-lg flex flex-col bg-white bg-opacity-70 shadow-lg"
                }, header(marketInfo), tmp));
}

var defaultUserHasPositions = {
  hasLong: false,
  hasShort: false
};

var make = MarketInteractionCard;

exports.Tab = Tab;
exports.onlyIfAllSomeWithDefault4 = onlyIfAllSomeWithDefault4;
exports.onlyIfAllSomeWithDefault3 = onlyIfAllSomeWithDefault3;
exports.optAddressWithDefaultZero = optAddressWithDefaultZero;
exports.allTabs = allTabs;
exports.tabToStr = tabToStr;
exports.strToTab = strToTab;
exports.defaultUserHasPositions = defaultUserHasPositions;
exports.useUserHasBalances = useUserHasBalances;
exports.useUserHasStakes = useUserHasStakes;
exports.useMarketInfo = useMarketInfo;
exports.header = header;
exports.SelectOptions = SelectOptions;
exports.wrapper = wrapper;
exports.NoBalancesView = NoBalancesView;
exports.determineDisplay = determineDisplay;
exports.UnstakeInteractionWrapper = UnstakeInteractionWrapper;
exports.StakeInteractionWrapper = StakeInteractionWrapper;
exports.RedeemInteractionWrapper = RedeemInteractionWrapper;
exports.make = make;
/* Mint Not a pure module */
