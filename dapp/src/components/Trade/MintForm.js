// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Form = require("../Form.js");
var Next = require("../../bindings/Next.js");
var Tick = require("../UI/Base/Tick.js");
var Curry = require("rescript/lib/js/curry.js");
var Modal = require("../UI/Base/Modal.js");
var React = require("react");
var Button = require("../UI/Base/Button.js");
var Config = require("../../Config.js");
var Ethers = require("../../ethereum/Ethers.js");
var Loader = require("../UI/Base/Loader.js");
var Ethers$1 = require("ethers");
var Globals = require("../../libraries/Globals.js");
var Js_math = require("rescript/lib/js/js_math.js");
var Tooltip = require("../UI/Base/Tooltip.js");
var Metamask = require("../UI/Base/Metamask.js");
var Contracts = require("../../ethereum/Contracts.js");
var Formality = require("re-formality/src/Formality.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var AmountInput = require("../UI/Base/AmountInput.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var TweetButton = require("../UI/TweetButton.js");
var Router = require("next/router");
var ContractHooks = require("../Testing/Admin/ContractHooks.js");
var ToastProvider = require("../UI/ToastProvider.js");
var ContractActions = require("../../ethereum/ContractActions.js");
var LongOrShortSelect = require("../UI/LongOrShortSelect.js");
var MessageUsOnDiscord = require("../Ethereum/MessageUsOnDiscord.js");
var ViewPositionButton = require("../UI/ViewPositionButton.js");
var ViewOnBlockExplorer = require("../Ethereum/ViewOnBlockExplorer.js");
var Formality__ReactUpdate = require("re-formality/src/Formality__ReactUpdate.js");

var validators_amount = {
  strategy: /* OnFirstSuccessOrFirstBlur */3,
  validate: (function (param) {
      var amount = param.amount;
      var amountRegex = /^[+]?\d+(\.\d+)?$/;
      if (amount === "") {
        return {
                TAG: 1,
                _0: "Amount is required",
                [Symbol.for("name")]: "Error"
              };
      } else if (amountRegex.test(amount)) {
        return Belt_Option.mapWithDefault(Ethers.Utils.parseEther(amount), {
                    TAG: 1,
                    _0: "Couldn't parse Ether value",
                    [Symbol.for("name")]: "Error"
                  }, (function (etherValue) {
                      return {
                              TAG: 0,
                              _0: etherValue,
                              [Symbol.for("name")]: "Ok"
                            };
                    }));
      } else {
        return {
                TAG: 1,
                _0: "Incorrect number format - please use '.' for floating points.",
                [Symbol.for("name")]: "Error"
              };
      }
    })
};

var validators = {
  isStaking: undefined,
  amount: validators_amount
};

function initialFieldsStatuses(_input) {
  return {
          isStaking: /* Pristine */0,
          amount: /* Pristine */0
        };
}

function initialState(input) {
  return {
          input: input,
          fieldsStatuses: {
            isStaking: /* Pristine */0,
            amount: /* Pristine */0
          },
          collectionsStatuses: undefined,
          formStatus: /* Editing */0,
          submissionStatus: /* NeverSubmitted */0
        };
}

function validateForm(input, validators, fieldsStatuses) {
  var match_0 = {
    TAG: 0,
    _0: input.isStaking,
    [Symbol.for("name")]: "Ok"
  };
  var match = fieldsStatuses.amount;
  var match_0$1 = match ? match._0 : Curry._1(validators.amount.validate, input);
  var isStakingResult = match_0;
  var isStakingResult$1;
  if (isStakingResult.TAG === /* Ok */0) {
    var amountResult = match_0$1;
    if (amountResult.TAG === /* Ok */0) {
      return {
              TAG: 0,
              output: {
                amount: amountResult._0,
                isStaking: isStakingResult._0
              },
              fieldsStatuses: {
                isStaking: {
                  _0: isStakingResult,
                  _1: /* Hidden */1,
                  [Symbol.for("name")]: "Dirty"
                },
                amount: {
                  _0: amountResult,
                  _1: /* Shown */0,
                  [Symbol.for("name")]: "Dirty"
                }
              },
              collectionsStatuses: undefined,
              [Symbol.for("name")]: "Valid"
            };
    }
    isStakingResult$1 = isStakingResult;
  } else {
    isStakingResult$1 = isStakingResult;
  }
  return {
          TAG: 1,
          fieldsStatuses: {
            isStaking: {
              _0: isStakingResult$1,
              _1: /* Hidden */1,
              [Symbol.for("name")]: "Dirty"
            },
            amount: {
              _0: match_0$1,
              _1: /* Shown */0,
              [Symbol.for("name")]: "Dirty"
            }
          },
          collectionsStatuses: undefined,
          [Symbol.for("name")]: "Invalid"
        };
}

function useForm(initialInput, onSubmit) {
  var memoizedInitialState = React.useMemo((function () {
          return initialState(initialInput);
        }), [initialInput]);
  var match = Formality__ReactUpdate.useReducer(memoizedInitialState, (function (state, action) {
          if (typeof action === "number") {
            switch (action) {
              case /* BlurIsStakingField */0 :
                  var result = Formality.validateFieldOnBlurWithoutValidator(state.input.isStaking, state.fieldsStatuses.isStaking, (function (status) {
                          var init = state.fieldsStatuses;
                          return {
                                  isStaking: status,
                                  amount: init.amount
                                };
                        }));
                  if (result !== undefined) {
                    return {
                            TAG: 0,
                            _0: {
                              input: state.input,
                              fieldsStatuses: result,
                              collectionsStatuses: state.collectionsStatuses,
                              formStatus: state.formStatus,
                              submissionStatus: state.submissionStatus
                            },
                            [Symbol.for("name")]: "Update"
                          };
                  } else {
                    return /* NoUpdate */0;
                  }
              case /* BlurAmountField */1 :
                  var result$1 = Formality.validateFieldOnBlurWithValidator(state.input, state.fieldsStatuses.amount, validators_amount, (function (status) {
                          var init = state.fieldsStatuses;
                          return {
                                  isStaking: init.isStaking,
                                  amount: status
                                };
                        }));
                  if (result$1 !== undefined) {
                    return {
                            TAG: 0,
                            _0: {
                              input: state.input,
                              fieldsStatuses: result$1,
                              collectionsStatuses: state.collectionsStatuses,
                              formStatus: state.formStatus,
                              submissionStatus: state.submissionStatus
                            },
                            [Symbol.for("name")]: "Update"
                          };
                  } else {
                    return /* NoUpdate */0;
                  }
              case /* Submit */2 :
                  var match = state.formStatus;
                  if (typeof match !== "number" && match.TAG === /* Submitting */0) {
                    return /* NoUpdate */0;
                  }
                  var match$1 = validateForm(state.input, validators, state.fieldsStatuses);
                  if (match$1.TAG !== /* Valid */0) {
                    return {
                            TAG: 0,
                            _0: {
                              input: state.input,
                              fieldsStatuses: match$1.fieldsStatuses,
                              collectionsStatuses: match$1.collectionsStatuses,
                              formStatus: /* Editing */0,
                              submissionStatus: /* AttemptedToSubmit */1
                            },
                            [Symbol.for("name")]: "Update"
                          };
                  }
                  var output = match$1.output;
                  var error = state.formStatus;
                  var tmp;
                  tmp = typeof error === "number" || error.TAG !== /* SubmissionFailed */1 ? undefined : Caml_option.some(error._0);
                  return {
                          TAG: 1,
                          _0: {
                            input: state.input,
                            fieldsStatuses: match$1.fieldsStatuses,
                            collectionsStatuses: match$1.collectionsStatuses,
                            formStatus: {
                              TAG: 0,
                              _0: tmp,
                              [Symbol.for("name")]: "Submitting"
                            },
                            submissionStatus: /* AttemptedToSubmit */1
                          },
                          _1: (function (param) {
                              var dispatch = param.dispatch;
                              return Curry._2(onSubmit, output, {
                                          notifyOnSuccess: (function (input) {
                                              return Curry._1(dispatch, {
                                                          TAG: 2,
                                                          _0: input,
                                                          [Symbol.for("name")]: "SetSubmittedStatus"
                                                        });
                                            }),
                                          notifyOnFailure: (function (error) {
                                              return Curry._1(dispatch, {
                                                          TAG: 3,
                                                          _0: error,
                                                          [Symbol.for("name")]: "SetSubmissionFailedStatus"
                                                        });
                                            }),
                                          reset: (function (param) {
                                              return Curry._1(dispatch, /* Reset */5);
                                            }),
                                          dismissSubmissionResult: (function (param) {
                                              return Curry._1(dispatch, /* DismissSubmissionResult */4);
                                            })
                                        });
                            }),
                          [Symbol.for("name")]: "UpdateWithSideEffects"
                        };
                  break;
              case /* DismissSubmissionError */3 :
                  var match$2 = state.formStatus;
                  if (typeof match$2 === "number" || match$2.TAG !== /* SubmissionFailed */1) {
                    return /* NoUpdate */0;
                  } else {
                    return {
                            TAG: 0,
                            _0: {
                              input: state.input,
                              fieldsStatuses: state.fieldsStatuses,
                              collectionsStatuses: state.collectionsStatuses,
                              formStatus: /* Editing */0,
                              submissionStatus: state.submissionStatus
                            },
                            [Symbol.for("name")]: "Update"
                          };
                  }
              case /* DismissSubmissionResult */4 :
                  var match$3 = state.formStatus;
                  if (typeof match$3 === "number") {
                    if (match$3 === /* Editing */0) {
                      return /* NoUpdate */0;
                    }
                    
                  } else if (match$3.TAG === /* Submitting */0) {
                    return /* NoUpdate */0;
                  }
                  return {
                          TAG: 0,
                          _0: {
                            input: state.input,
                            fieldsStatuses: state.fieldsStatuses,
                            collectionsStatuses: state.collectionsStatuses,
                            formStatus: /* Editing */0,
                            submissionStatus: state.submissionStatus
                          },
                          [Symbol.for("name")]: "Update"
                        };
              case /* Reset */5 :
                  return {
                          TAG: 0,
                          _0: initialState(initialInput),
                          [Symbol.for("name")]: "Update"
                        };
              
            }
          } else {
            switch (action.TAG | 0) {
              case /* UpdateIsStakingField */0 :
                  var nextInput = Curry._1(action._0, state.input);
                  return {
                          TAG: 0,
                          _0: {
                            input: nextInput,
                            fieldsStatuses: Formality.validateFieldOnChangeWithoutValidator(nextInput.isStaking, (function (status) {
                                    var init = state.fieldsStatuses;
                                    return {
                                            isStaking: status,
                                            amount: init.amount
                                          };
                                  })),
                            collectionsStatuses: state.collectionsStatuses,
                            formStatus: state.formStatus,
                            submissionStatus: state.submissionStatus
                          },
                          [Symbol.for("name")]: "Update"
                        };
              case /* UpdateAmountField */1 :
                  var nextInput$1 = Curry._1(action._0, state.input);
                  return {
                          TAG: 0,
                          _0: {
                            input: nextInput$1,
                            fieldsStatuses: Formality.validateFieldOnChangeWithValidator(nextInput$1, state.fieldsStatuses.amount, state.submissionStatus, validators_amount, (function (status) {
                                    var init = state.fieldsStatuses;
                                    return {
                                            isStaking: init.isStaking,
                                            amount: status
                                          };
                                  })),
                            collectionsStatuses: state.collectionsStatuses,
                            formStatus: state.formStatus,
                            submissionStatus: state.submissionStatus
                          },
                          [Symbol.for("name")]: "Update"
                        };
              case /* SetSubmittedStatus */2 :
                  var input = action._0;
                  if (input !== undefined) {
                    return {
                            TAG: 0,
                            _0: {
                              input: input,
                              fieldsStatuses: {
                                isStaking: /* Pristine */0,
                                amount: /* Pristine */0
                              },
                              collectionsStatuses: state.collectionsStatuses,
                              formStatus: /* Submitted */1,
                              submissionStatus: state.submissionStatus
                            },
                            [Symbol.for("name")]: "Update"
                          };
                  } else {
                    return {
                            TAG: 0,
                            _0: {
                              input: state.input,
                              fieldsStatuses: {
                                isStaking: /* Pristine */0,
                                amount: /* Pristine */0
                              },
                              collectionsStatuses: state.collectionsStatuses,
                              formStatus: /* Submitted */1,
                              submissionStatus: state.submissionStatus
                            },
                            [Symbol.for("name")]: "Update"
                          };
                  }
              case /* SetSubmissionFailedStatus */3 :
                  return {
                          TAG: 0,
                          _0: {
                            input: state.input,
                            fieldsStatuses: state.fieldsStatuses,
                            collectionsStatuses: state.collectionsStatuses,
                            formStatus: {
                              TAG: 1,
                              _0: action._0,
                              [Symbol.for("name")]: "SubmissionFailed"
                            },
                            submissionStatus: state.submissionStatus
                          },
                          [Symbol.for("name")]: "Update"
                        };
              case /* MapSubmissionError */4 :
                  var map = action._0;
                  var error$1 = state.formStatus;
                  if (typeof error$1 === "number") {
                    return /* NoUpdate */0;
                  }
                  if (error$1.TAG !== /* Submitting */0) {
                    return {
                            TAG: 0,
                            _0: {
                              input: state.input,
                              fieldsStatuses: state.fieldsStatuses,
                              collectionsStatuses: state.collectionsStatuses,
                              formStatus: {
                                TAG: 1,
                                _0: Curry._1(map, error$1._0),
                                [Symbol.for("name")]: "SubmissionFailed"
                              },
                              submissionStatus: state.submissionStatus
                            },
                            [Symbol.for("name")]: "Update"
                          };
                  }
                  var error$2 = error$1._0;
                  if (error$2 !== undefined) {
                    return {
                            TAG: 0,
                            _0: {
                              input: state.input,
                              fieldsStatuses: state.fieldsStatuses,
                              collectionsStatuses: state.collectionsStatuses,
                              formStatus: {
                                TAG: 0,
                                _0: Caml_option.some(Curry._1(map, Caml_option.valFromOption(error$2))),
                                [Symbol.for("name")]: "Submitting"
                              },
                              submissionStatus: state.submissionStatus
                            },
                            [Symbol.for("name")]: "Update"
                          };
                  } else {
                    return /* NoUpdate */0;
                  }
              
            }
          }
        }));
  var dispatch = match[1];
  var state = match[0];
  var match$1 = state.formStatus;
  var tmp;
  tmp = typeof match$1 === "number" || match$1.TAG !== /* Submitting */0 ? false : true;
  return {
          updateIsStaking: (function (nextInputFn, nextValue) {
              return Curry._1(dispatch, {
                          TAG: 0,
                          _0: (function (__x) {
                              return Curry._2(nextInputFn, __x, nextValue);
                            }),
                          [Symbol.for("name")]: "UpdateIsStakingField"
                        });
            }),
          updateAmount: (function (nextInputFn, nextValue) {
              return Curry._1(dispatch, {
                          TAG: 1,
                          _0: (function (__x) {
                              return Curry._2(nextInputFn, __x, nextValue);
                            }),
                          [Symbol.for("name")]: "UpdateAmountField"
                        });
            }),
          blurIsStaking: (function (param) {
              return Curry._1(dispatch, /* BlurIsStakingField */0);
            }),
          blurAmount: (function (param) {
              return Curry._1(dispatch, /* BlurAmountField */1);
            }),
          isStakingResult: Formality.exposeFieldResult(state.fieldsStatuses.isStaking),
          amountResult: Formality.exposeFieldResult(state.fieldsStatuses.amount),
          input: state.input,
          status: state.formStatus,
          dirty: (function (param) {
              var match = state.fieldsStatuses;
              if (match.isStaking || match.amount) {
                return true;
              } else {
                return false;
              }
            }),
          valid: (function (param) {
              var match = validateForm(state.input, validators, state.fieldsStatuses);
              if (match.TAG === /* Valid */0) {
                return true;
              } else {
                return false;
              }
            }),
          submitting: tmp,
          submit: (function (param) {
              return Curry._1(dispatch, /* Submit */2);
            }),
          dismissSubmissionError: (function (param) {
              return Curry._1(dispatch, /* DismissSubmissionError */3);
            }),
          dismissSubmissionResult: (function (param) {
              return Curry._1(dispatch, /* DismissSubmissionResult */4);
            }),
          mapSubmissionError: (function (map) {
              return Curry._1(dispatch, {
                          TAG: 4,
                          _0: map,
                          [Symbol.for("name")]: "MapSubmissionError"
                        });
            }),
          reset: (function (param) {
              return Curry._1(dispatch, /* Reset */5);
            })
        };
}

var MintForm = {
  validators: validators,
  initialFieldsStatuses: initialFieldsStatuses,
  initialCollectionsStatuses: undefined,
  initialState: initialState,
  validateForm: validateForm,
  useForm: useForm
};

var initialInput = {
  amount: "",
  isStaking: true
};

function useBalanceAndApproved(erc20Address, spender) {
  var match = ContractHooks.useErc20BalanceRefresh(erc20Address);
  var match$1 = ContractHooks.useERC20ApprovedRefresh(erc20Address, spender);
  return [
          match.data,
          match$1.data
        ];
}

function isGreaterThanApproval(amount, amountApproved) {
  return amount.gt(amountApproved);
}

function isGreaterThanBalance(amount, balance) {
  return amount.gt(balance);
}

function MintForm$SubmitButtonAndTxTracker(Props) {
  var txStateApprove = Props.txStateApprove;
  var txStateMint = Props.txStateMint;
  var resetFormButton = Props.resetFormButton;
  var isLong = Props.isLong;
  var marketName = Props.marketName;
  var tokenToMint = Props.tokenToMint;
  var buttonText = Props.buttonText;
  var buttonDisabled = Props.buttonDisabled;
  var randomMintTweetMessage = function (isLong, marketName) {
    var position = isLong ? "long" : "short";
    var possibleTweetMessages = [
      "Boom bam baby!💥 I just minted " + position + " tokens on " + marketName + "! @float_capital 🌊",
      "Look at me, look at me! I just went " + position + " on " + marketName + "! 🐬 @float_capital 🌊",
      "Cue Jaws music! 🦈 I just went " + position + " on " + marketName + "! @foat_capital 🌊"
    ];
    return Belt_Option.getWithDefault(Belt_Array.get(possibleTweetMessages, Js_math.random_int(0, possibleTweetMessages.length)), "");
  };
  var exit = 0;
  if (typeof txStateApprove === "number") {
    if (txStateApprove !== /* UnInitialised */0) {
      return React.createElement(React.Fragment, undefined, React.createElement(Modal.make, {
                      id: 1,
                      children: React.createElement("div", {
                            className: "text-center mx-3 my-6"
                          }, React.createElement(Loader.Ellipses.make, {}), React.createElement("p", undefined, "Please approve your " + Config.paymentTokenName + " token "))
                    }), React.createElement(Button.make, {
                      onClick: (function (param) {
                          
                        }),
                      children: buttonText,
                      disabled: true
                    }));
    }
    exit = 1;
  } else {
    switch (txStateApprove.TAG | 0) {
      case /* SignedAndSubmitted */0 :
          return React.createElement(React.Fragment, undefined, React.createElement(Modal.make, {
                          id: 2,
                          children: React.createElement("div", {
                                className: "text-center m-3"
                              }, React.createElement("div", {
                                    className: "m-2"
                                  }, React.createElement(Loader.Mini.make, {})), React.createElement("p", undefined, "Approval transaction pending... "), React.createElement(ViewOnBlockExplorer.make, {
                                    txHash: txStateApprove._0
                                  }))
                        }), React.createElement(Button.make, {
                          onClick: (function (param) {
                              
                            }),
                          children: buttonText,
                          disabled: true
                        }));
      case /* Declined */1 :
          return React.createElement(React.Fragment, undefined, Curry._1(resetFormButton, undefined));
      case /* Complete */2 :
          if (typeof txStateMint === "number") {
            exit = 2;
          } else {
            if (txStateMint.TAG === /* SignedAndSubmitted */0) {
              return React.createElement(React.Fragment, undefined, React.createElement(Modal.make, {
                              id: 6,
                              children: React.createElement("div", {
                                    className: "text-center m-3"
                                  }, React.createElement("p", undefined, "Approval confirmed 🎉"), React.createElement(ViewOnBlockExplorer.make, {
                                        txHash: txStateApprove._0.transactionHash
                                      }), React.createElement("h1", undefined, "Pending minting " + tokenToMint, React.createElement(ViewOnBlockExplorer.make, {
                                            txHash: txStateMint._0
                                          })))
                            }), React.createElement(Button.make, {
                              onClick: (function (param) {
                                  
                                }),
                              children: buttonText,
                              disabled: true
                            }));
            }
            exit = 1;
          }
          break;
      case /* Failed */3 :
          return React.createElement(React.Fragment, undefined, React.createElement(Modal.make, {
                          id: 4,
                          children: React.createElement("div", {
                                className: "text-center m-3"
                              }, React.createElement("p", undefined, "The transaction failed."), React.createElement(ViewOnBlockExplorer.make, {
                                    txHash: txStateApprove._0
                                  }), React.createElement(MessageUsOnDiscord.make, {}))
                        }), Curry._1(resetFormButton, undefined));
      
    }
  }
  switch (exit) {
    case 1 :
        if (typeof txStateMint === "number") {
          if (txStateMint === /* UnInitialised */0) {
            return React.createElement(Button.make, {
                        onClick: (function (param) {
                            
                          }),
                        children: buttonText,
                        disabled: buttonDisabled
                      });
          } else {
            return React.createElement(React.Fragment, undefined, React.createElement(Modal.make, {
                            id: 5,
                            children: React.createElement("div", {
                                  className: "text-center m-3"
                                }, React.createElement(Loader.Ellipses.make, {}), React.createElement("h1", undefined, "Confirm the transaction to mint " + tokenToMint))
                          }), React.createElement(Button.make, {
                            onClick: (function (param) {
                                
                              }),
                            children: buttonText,
                            disabled: true
                          }));
          }
        }
        switch (txStateMint.TAG | 0) {
          case /* SignedAndSubmitted */0 :
              return React.createElement(React.Fragment, undefined, React.createElement(Modal.make, {
                              id: 7,
                              children: React.createElement("div", {
                                    className: "text-center m-3"
                                  }, React.createElement("div", {
                                        className: "m-2"
                                      }, React.createElement(Loader.Mini.make, {})), React.createElement("p", undefined, "Minting transaction pending... "), React.createElement(ViewOnBlockExplorer.make, {
                                        txHash: txStateMint._0
                                      }))
                            }), React.createElement(Button.make, {
                              onClick: (function (param) {
                                  
                                }),
                              children: buttonText,
                              disabled: true
                            }));
          case /* Declined */1 :
              return React.createElement(React.Fragment, undefined, React.createElement(Modal.make, {
                              id: 9,
                              children: React.createElement("div", {
                                    className: "text-center m-3"
                                  }, React.createElement("p", undefined, "The transaction was rejected by your wallet"), React.createElement(MessageUsOnDiscord.make, {}))
                            }), Curry._1(resetFormButton, undefined));
          case /* Complete */2 :
              return React.createElement(React.Fragment, undefined, React.createElement(Modal.make, {
                              id: 8,
                              children: React.createElement("div", {
                                    className: "text-center m-3"
                                  }, React.createElement(Tick.make, {}), React.createElement("p", undefined, "Transaction complete 🎉"), React.createElement(TweetButton.make, {
                                        message: randomMintTweetMessage(isLong, marketName)
                                      }), React.createElement(Metamask.AddTokenButton.make, {
                                        token: Config.config.contracts.FloatToken,
                                        tokenSymbol: (
                                          isLong ? "↗️" : "↘️"
                                        ) + marketName
                                      }), React.createElement(ViewPositionButton.make, {}))
                            }));
          case /* Failed */3 :
              return React.createElement(React.Fragment, undefined, React.createElement(Modal.make, {
                              id: 10,
                              children: React.createElement("div", {
                                    className: "text-center m-3"
                                  }, React.createElement("h1", undefined, "The transaction failed."), React.createElement(ViewOnBlockExplorer.make, {
                                        txHash: txStateMint._0
                                      }), React.createElement(MessageUsOnDiscord.make, {}))
                            }), Curry._1(resetFormButton, undefined));
          
        }
    case 2 :
        return React.createElement(React.Fragment, undefined, React.createElement(Modal.make, {
                        id: 3,
                        children: React.createElement("div", {
                              className: "text-center mx-3 my-6"
                            }, React.createElement(Loader.Ellipses.make, {}), React.createElement("p", undefined, "Confirm transaction to mint " + tokenToMint))
                      }), React.createElement(Button.make, {
                        onClick: (function (param) {
                            
                          }),
                        children: buttonText,
                        disabled: true
                      }));
    
  }
}

var SubmitButtonAndTxTracker = {
  make: MintForm$SubmitButtonAndTxTracker
};

function MintForm$MintFormInput(Props) {
  var onSubmitOpt = Props.onSubmit;
  var onChangeSideOpt = Props.onChangeSide;
  var isLong = Props.isLong;
  var valueAmountInputOpt = Props.valueAmountInput;
  var optDaiBalanceOpt = Props.optDaiBalance;
  var onBlurAmountOpt = Props.onBlurAmount;
  var onChangeAmountInputOpt = Props.onChangeAmountInput;
  var onMaxClickOpt = Props.onMaxClick;
  var optErrorMessageOpt = Props.optErrorMessage;
  var isStakingOpt = Props.isStaking;
  var disabledOpt = Props.disabled;
  var onBlurIsStakingOpt = Props.onBlurIsStaking;
  var onChangeIsStakingOpt = Props.onChangeIsStaking;
  var submitButtonOpt = Props.submitButton;
  var onSubmit = onSubmitOpt !== undefined ? onSubmitOpt : (function (param) {
        
      });
  var onChangeSide = onChangeSideOpt !== undefined ? onChangeSideOpt : (function (param) {
        
      });
  var valueAmountInput = valueAmountInputOpt !== undefined ? valueAmountInputOpt : "";
  var optDaiBalance = optDaiBalanceOpt !== undefined ? Caml_option.valFromOption(optDaiBalanceOpt) : undefined;
  var onBlurAmount = onBlurAmountOpt !== undefined ? onBlurAmountOpt : (function (param) {
        
      });
  var onChangeAmountInput = onChangeAmountInputOpt !== undefined ? onChangeAmountInputOpt : (function (param) {
        
      });
  var onMaxClick = onMaxClickOpt !== undefined ? onMaxClickOpt : (function (param) {
        
      });
  var optErrorMessage = optErrorMessageOpt !== undefined ? Caml_option.valFromOption(optErrorMessageOpt) : undefined;
  var isStaking = isStakingOpt !== undefined ? isStakingOpt : true;
  var disabled = disabledOpt !== undefined ? disabledOpt : false;
  var onBlurIsStaking = onBlurIsStakingOpt !== undefined ? onBlurIsStakingOpt : (function (param) {
        
      });
  var onChangeIsStaking = onChangeIsStakingOpt !== undefined ? onChangeIsStakingOpt : (function (param) {
        
      });
  var submitButton = submitButtonOpt !== undefined ? Caml_option.valFromOption(submitButtonOpt) : React.createElement(Button.make, {
          children: "Login & Mint"
        });
  var router = Router.useRouter();
  var formInput = React.createElement(React.Fragment, undefined, React.createElement(LongOrShortSelect.make, {
            isLong: isLong,
            selectPosition: Curry.__1(onChangeSide),
            disabled: disabled
          }), React.createElement(AmountInput.make, {
            value: valueAmountInput,
            optBalance: optDaiBalance,
            disabled: disabled,
            onBlur: onBlurAmount,
            onChange: onChangeAmountInput,
            onMaxClick: onMaxClick,
            optCurrency: Config.paymentTokenName
          }), optErrorMessage !== undefined ? React.createElement("div", {
              className: "text-red-500 text-xs"
            }, optErrorMessage) : null, React.createElement("div", {
            className: "flex justify-between items-center"
          }, React.createElement("div", {
                className: "flex items-center"
              }, React.createElement("input", {
                    className: "mr-2",
                    id: "stake-checkbox",
                    checked: isStaking,
                    disabled: disabled,
                    type: "checkbox",
                    onBlur: onBlurIsStaking,
                    onChange: onChangeIsStaking
                  }), React.createElement("label", {
                    className: "text-xs",
                    htmlFor: "stake-checkbox"
                  }, "Stake " + (
                    isLong ? "long" : "short"
                  ) + " tokens "), React.createElement("div", {
                    className: "ml-1"
                  }, React.createElement(Tooltip.make, {
                        tip: "Stake your synthetic asset tokens to earn FLOAT tokens"
                      }))), React.createElement("p", {
                className: "text-xxs hover:text-gray-500"
              }, React.createElement("a", {
                    href: "https://docs.float.capital/docs/stake",
                    rel: "noopenner noreferrer",
                    target: "_blank"
                  }, "Learn more about staking"))));
  return React.createElement("div", {
              className: "screen-centered-container h-full "
            }, React.createElement(Form.make, {
                  className: "h-full",
                  onSubmit: onSubmit,
                  children: null
                }, React.createElement("div", {
                      className: "relative"
                    }, formInput), submitButton), Config.networkId === 80001 ? React.createElement("p", {
                    className: "cursor-pointer text-xxs py-2",
                    onClick: (function (param) {
                        router.push("/faucet");
                        
                      })
                  }, "Visit our ", React.createElement("a", {
                        className: "hover:bg-white underline"
                      }, "faucet"), " if you need more aave test DAI.") : null);
}

var MintFormInput = {
  make: MintForm$MintFormInput
};

function MintForm$MintFormSignedIn(Props) {
  var market = Props.market;
  var isLong = Props.isLong;
  var signer = Props.signer;
  var match = ContractActions.useContractFunction(signer);
  var setTxState = match[2];
  var txState = match[1];
  var contractExecutionHandler = match[0];
  var match$1 = ContractActions.useContractFunction(signer);
  var setTxStateApprove = match$1[2];
  var txStateApprove = match$1[1];
  var contractExecutionHandlerApprove = match$1[0];
  var match$2 = React.useState(function () {
        return function (param) {
          
        };
      });
  var setContractActionToCallAfterApproval = match$2[1];
  var contractActionToCallAfterApproval = match$2[0];
  var match$3 = useBalanceAndApproved(Config.dai, Config.longShort);
  var optDaiAmountApproved = match$3[1];
  var optDaiBalance = match$3[0];
  var form = useForm(initialInput, (function (param, _form) {
          var isStaking = param.isStaking;
          var amount = param.amount;
          var mintFunction = function (param) {
            var tmp;
            if (isLong) {
              var arg = market.marketIndex;
              tmp = (function (param) {
                  return param.mintLong(arg, amount);
                });
            } else {
              var arg$1 = market.marketIndex;
              tmp = (function (param) {
                  return param.mintShort(arg$1, amount);
                });
            }
            return Curry._2(contractExecutionHandler, (function (param) {
                          return Contracts.LongShort.make(Config.longShort, param);
                        }), tmp);
          };
          var mintAndStakeFunction = function (param) {
            var tmp;
            if (isLong) {
              var arg = market.marketIndex;
              tmp = (function (param) {
                  return param.mintLongAndStake(arg, amount);
                });
            } else {
              var arg$1 = market.marketIndex;
              tmp = (function (param) {
                  return param.mintShortAndStake(arg$1, amount);
                });
            }
            return Curry._2(contractExecutionHandler, (function (param) {
                          return Contracts.LongShort.make(Config.longShort, param);
                        }), tmp);
          };
          var needsToApprove = amount.gt(Belt_Option.getWithDefault(optDaiAmountApproved, Ethers$1.BigNumber.from("0")));
          if (needsToApprove) {
            Curry._1(setContractActionToCallAfterApproval, (function (param) {
                    if (isStaking) {
                      return mintAndStakeFunction;
                    } else {
                      return mintFunction;
                    }
                  }));
            var arg = Globals.amountForApproval(amount);
            return Curry._2(contractExecutionHandlerApprove, (function (param) {
                          return Contracts.Erc20.make(Config.dai, param);
                        }), (function (param) {
                          return param.approve(Config.longShort, arg);
                        }));
          } else if (isStaking) {
            return mintAndStakeFunction(undefined);
          } else {
            return mintFunction(undefined);
          }
        }));
  var match$4 = form.amountResult;
  var formAmount = match$4 !== undefined && match$4.TAG === /* Ok */0 ? Caml_option.some(match$4._0) : undefined;
  var resetFormButton = function (param) {
    return React.createElement(Button.make, {
                onClick: (function (param) {
                    Curry._1(form.reset, undefined);
                    Curry._1(setTxStateApprove, (function (param) {
                            return /* UnInitialised */0;
                          }));
                    return Curry._1(setTxState, (function (param) {
                                  return /* UnInitialised */0;
                                }));
                  }),
                children: "Reset & Mint Again"
              });
  };
  var tokenToMint = isLong ? "long " + market.name : "short " + market.name;
  var stakingText = form.input.isStaking ? "Mint & Stake" : "Mint";
  var approveConnector = form.input.isStaking ? "," : " &";
  var position = isLong ? "long" : "short";
  var match$5;
  var exit = 0;
  if (formAmount !== undefined && optDaiBalance !== undefined && optDaiAmountApproved !== undefined) {
    var amount = Caml_option.valFromOption(formAmount);
    var needsToApprove = amount.gt(Caml_option.valFromOption(optDaiAmountApproved));
    var greaterThanBalance = amount.gt(Caml_option.valFromOption(optDaiBalance));
    match$5 = greaterThanBalance ? [
        "Amount is greater than your balance",
        "Insufficient balance",
        true
      ] : [
        undefined,
        needsToApprove ? "Approve" + approveConnector + " " + stakingText + " " + position + " position" : stakingText + " " + position + " position",
        !Curry._1(form.valid, undefined)
      ];
  } else {
    exit = 1;
  }
  if (exit === 1) {
    match$5 = [
      undefined,
      stakingText + " " + position + " position",
      true
    ];
  }
  var toastDispatch = React.useContext(ToastProvider.DispatchToastContext.context);
  var router = Router.useRouter();
  React.useEffect((function () {
          if (typeof txStateApprove === "number") {
            if (txStateApprove !== /* UnInitialised */0) {
              Curry._1(toastDispatch, {
                    _0: "Please approve your " + Config.paymentTokenName + " token",
                    _1: "",
                    _2: /* Info */2,
                    [Symbol.for("name")]: "Show"
                  });
            }
            
          } else {
            switch (txStateApprove.TAG | 0) {
              case /* SignedAndSubmitted */0 :
                  Curry._1(toastDispatch, {
                        _0: "Approval transaction processing",
                        _1: "",
                        _2: /* Info */2,
                        [Symbol.for("name")]: "Show"
                      });
                  break;
              case /* Declined */1 :
                  Curry._1(toastDispatch, {
                        _0: "The transaction was rejected by your wallet",
                        _1: txStateApprove._0,
                        _2: /* Error */0,
                        [Symbol.for("name")]: "Show"
                      });
                  break;
              case /* Complete */2 :
                  Curry._1(contractActionToCallAfterApproval, undefined);
                  Curry._1(setTxStateApprove, (function (param) {
                          return /* UnInitialised */0;
                        }));
                  Curry._1(toastDispatch, {
                        _0: "Approve transaction confirmed",
                        _1: "",
                        _2: /* Success */3,
                        [Symbol.for("name")]: "Show"
                      });
                  break;
              case /* Failed */3 :
                  Curry._1(toastDispatch, {
                        _0: "The transaction failed",
                        _1: "",
                        _2: /* Error */0,
                        [Symbol.for("name")]: "Show"
                      });
                  break;
              
            }
          }
          
        }), [txStateApprove]);
  React.useEffect((function () {
          if (typeof txState === "number") {
            if (txState !== /* UnInitialised */0) {
              Curry._1(toastDispatch, {
                    _0: "Sign the transaction to mint " + tokenToMint,
                    _1: "",
                    _2: /* Info */2,
                    [Symbol.for("name")]: "Show"
                  });
            }
            
          } else {
            switch (txState.TAG | 0) {
              case /* SignedAndSubmitted */0 :
                  Curry._1(toastDispatch, {
                        _0: "Minting transaction pending",
                        _1: "",
                        _2: /* Info */2,
                        [Symbol.for("name")]: "Show"
                      });
                  break;
              case /* Declined */1 :
                  Curry._1(toastDispatch, {
                        _0: "The transaction was rejected by your wallet",
                        _1: txState._0,
                        _2: /* Warning */1,
                        [Symbol.for("name")]: "Show"
                      });
                  break;
              case /* Complete */2 :
                  Curry._1(toastDispatch, {
                        _0: "Mint transaction confirmed",
                        _1: "",
                        _2: /* Success */3,
                        [Symbol.for("name")]: "Show"
                      });
                  break;
              case /* Failed */3 :
                  Curry._1(toastDispatch, {
                        _0: "The transaction failed",
                        _1: "",
                        _2: /* Error */0,
                        [Symbol.for("name")]: "Show"
                      });
                  break;
              
            }
          }
          
        }), [txState]);
  return React.createElement(MintForm$MintFormInput, {
              onSubmit: form.submit,
              onChangeSide: (function (newPosition) {
                  router.query["actionOption"] = newPosition;
                  router.query["token"] = isLong ? Ethers.Utils.ethAdrToLowerStr(market.syntheticLong.tokenAddress) : Ethers.Utils.ethAdrToLowerStr(market.syntheticShort.tokenAddress);
                  return Next.Router.pushObjShallow(router, {
                              pathname: router.pathname,
                              query: router.query
                            });
                }),
              isLong: isLong,
              valueAmountInput: form.input.amount,
              optDaiBalance: optDaiBalance,
              onBlurAmount: (function (param) {
                  return Curry._1(form.blurAmount, undefined);
                }),
              onChangeAmountInput: (function ($$event) {
                  return Curry._2(form.updateAmount, (function (input, amount) {
                                return {
                                        amount: amount,
                                        isStaking: input.isStaking
                                      };
                              }), $$event.target.value);
                }),
              onMaxClick: (function (param) {
                  return Curry._2(form.updateAmount, (function (input, amount) {
                                return {
                                        amount: amount,
                                        isStaking: input.isStaking
                                      };
                              }), optDaiBalance !== undefined ? Ethers.Utils.formatEther(Caml_option.valFromOption(optDaiBalance)) : "0");
                }),
              optErrorMessage: match$5[0],
              isStaking: form.input.isStaking,
              disabled: form.submitting,
              onBlurIsStaking: (function (param) {
                  return Curry._1(form.blurIsStaking, undefined);
                }),
              onChangeIsStaking: (function ($$event) {
                  return Curry._2(form.updateIsStaking, (function (input, value) {
                                return {
                                        amount: input.amount,
                                        isStaking: value
                                      };
                              }), $$event.target.checked);
                }),
              submitButton: React.createElement(MintForm$SubmitButtonAndTxTracker, {
                    txStateApprove: txStateApprove,
                    txStateMint: txState,
                    resetFormButton: resetFormButton,
                    isLong: isLong,
                    marketName: market.name,
                    tokenToMint: tokenToMint,
                    buttonText: match$5[1],
                    buttonDisabled: match$5[2]
                  })
            });
}

var MintFormSignedIn = {
  make: MintForm$MintFormSignedIn
};

function MintForm$1(Props) {
  var market = Props.market;
  var isLong = Props.isLong;
  var router = Router.useRouter();
  var optSigner = ContractActions.useSigner(undefined);
  if (optSigner !== undefined) {
    return React.createElement(MintForm$MintFormSignedIn, {
                market: market,
                isLong: isLong,
                signer: optSigner
              });
  } else {
    return React.createElement("div", {
                onClick: (function (param) {
                    router.push("/login?nextPath=" + router.asPath);
                    
                  })
              }, React.createElement(MintForm$MintFormInput, {
                    isLong: isLong
                  }));
  }
}

var make = MintForm$1;

exports.MintForm = MintForm;
exports.initialInput = initialInput;
exports.useBalanceAndApproved = useBalanceAndApproved;
exports.isGreaterThanApproval = isGreaterThanApproval;
exports.isGreaterThanBalance = isGreaterThanBalance;
exports.SubmitButtonAndTxTracker = SubmitButtonAndTxTracker;
exports.MintFormInput = MintFormInput;
exports.MintFormSignedIn = MintFormSignedIn;
exports.make = make;
/* Form Not a pure module */
