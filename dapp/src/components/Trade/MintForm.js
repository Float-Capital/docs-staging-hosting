// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Form from "../Testing/Admin/Form.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as React from "react";
import * as Button from "../UI/Button.js";
import * as Config from "../../Config.js";
import * as Ethers from "../../ethereum/Ethers.js";
import * as Ethers$1 from "ethers";
import * as Globals from "../../libraries/Globals.js";
import * as Queries from "../../data/Queries.js";
import * as ViewBox from "../UI/ViewBox.js";
import * as Contracts from "../../ethereum/Contracts.js";
import * as Formality from "re-formality/src/Formality.js";
import * as AmountInput from "../UI/AmountInput.js";
import * as Belt_Option from "bs-platform/lib/es6/belt_Option.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";
import * as RootProvider from "../../libraries/RootProvider.js";
import * as ContractHooks from "../Testing/Admin/ContractHooks.js";
import * as ContractActions from "../../ethereum/ContractActions.js";
import * as Formality__ReactUpdate from "re-formality/src/Formality__ReactUpdate.js";

var validators_isLong = {
  strategy: /* OnFirstChange */1,
  validate: (function (param) {
      return {
              TAG: 0,
              _0: param.isLong,
              [Symbol.for("name")]: "Ok"
            };
    })
};

var validators_amount = {
  strategy: /* OnFirstBlur */0,
  validate: (function (param) {
      var amount = param.amount;
      var amountRegex = /^[+]?\d+(\.\d+)?$/;
      if (amount === "") {
        return {
                TAG: 1,
                _0: "Amount is required",
                [Symbol.for("name")]: "Error"
              };
      } else if (amountRegex.test(amount)) {
        return Belt_Option.mapWithDefault(Ethers.Utils.parseEther(amount), {
                    TAG: 1,
                    _0: "Couldn't parse Ether value",
                    [Symbol.for("name")]: "Error"
                  }, (function (etherValue) {
                      return {
                              TAG: 0,
                              _0: etherValue,
                              [Symbol.for("name")]: "Ok"
                            };
                    }));
      } else {
        return {
                TAG: 1,
                _0: "Incorrect number format - please use '.' for floating points.",
                [Symbol.for("name")]: "Error"
              };
      }
    })
};

var validators = {
  isStaking: undefined,
  isLong: validators_isLong,
  amount: validators_amount
};

function initialFieldsStatuses(_input) {
  return {
          isStaking: /* Pristine */0,
          isLong: /* Pristine */0,
          amount: /* Pristine */0
        };
}

function initialState(input) {
  return {
          input: input,
          fieldsStatuses: {
            isStaking: /* Pristine */0,
            isLong: /* Pristine */0,
            amount: /* Pristine */0
          },
          collectionsStatuses: undefined,
          formStatus: /* Editing */0,
          submissionStatus: /* NeverSubmitted */0
        };
}

function validateForm(input, validators, fieldsStatuses) {
  var match_0 = {
    TAG: 0,
    _0: input.isStaking,
    [Symbol.for("name")]: "Ok"
  };
  var match = fieldsStatuses.isLong;
  var match_0$1 = match ? match._0 : Curry._1(validators.isLong.validate, input);
  var match$1 = fieldsStatuses.amount;
  var match_0$2 = match$1 ? match$1._0 : Curry._1(validators.amount.validate, input);
  var isStakingResult = match_0;
  var isStakingResult$1;
  if (isStakingResult.TAG === /* Ok */0) {
    var isLongResult = match_0$1;
    if (isLongResult.TAG === /* Ok */0) {
      var amountResult = match_0$2;
      if (amountResult.TAG === /* Ok */0) {
        return {
                TAG: 0,
                output: {
                  amount: amountResult._0,
                  isLong: isLongResult._0,
                  isStaking: isStakingResult._0
                },
                fieldsStatuses: {
                  isStaking: {
                    _0: isStakingResult,
                    _1: /* Hidden */1,
                    [Symbol.for("name")]: "Dirty"
                  },
                  isLong: {
                    _0: isLongResult,
                    _1: /* Shown */0,
                    [Symbol.for("name")]: "Dirty"
                  },
                  amount: {
                    _0: amountResult,
                    _1: /* Shown */0,
                    [Symbol.for("name")]: "Dirty"
                  }
                },
                collectionsStatuses: undefined,
                [Symbol.for("name")]: "Valid"
              };
      }
      isStakingResult$1 = isStakingResult;
    } else {
      isStakingResult$1 = isStakingResult;
    }
  } else {
    isStakingResult$1 = isStakingResult;
  }
  return {
          TAG: 1,
          fieldsStatuses: {
            isStaking: {
              _0: isStakingResult$1,
              _1: /* Hidden */1,
              [Symbol.for("name")]: "Dirty"
            },
            isLong: {
              _0: match_0$1,
              _1: /* Shown */0,
              [Symbol.for("name")]: "Dirty"
            },
            amount: {
              _0: match_0$2,
              _1: /* Shown */0,
              [Symbol.for("name")]: "Dirty"
            }
          },
          collectionsStatuses: undefined,
          [Symbol.for("name")]: "Invalid"
        };
}

function useForm(initialInput, onSubmit) {
  var memoizedInitialState = React.useMemo((function () {
          return initialState(initialInput);
        }), [initialInput]);
  var match = Formality__ReactUpdate.useReducer(memoizedInitialState, (function (state, action) {
          if (typeof action === "number") {
            switch (action) {
              case /* BlurIsStakingField */0 :
                  var result = Formality.validateFieldOnBlurWithoutValidator(state.input.isStaking, state.fieldsStatuses.isStaking, (function (status) {
                          var init = state.fieldsStatuses;
                          return {
                                  isStaking: status,
                                  isLong: init.isLong,
                                  amount: init.amount
                                };
                        }));
                  if (result !== undefined) {
                    return {
                            TAG: 0,
                            _0: {
                              input: state.input,
                              fieldsStatuses: result,
                              collectionsStatuses: state.collectionsStatuses,
                              formStatus: state.formStatus,
                              submissionStatus: state.submissionStatus
                            },
                            [Symbol.for("name")]: "Update"
                          };
                  } else {
                    return /* NoUpdate */0;
                  }
              case /* BlurIsLongField */1 :
                  var result$1 = Formality.validateFieldOnBlurWithValidator(state.input, state.fieldsStatuses.isLong, validators_isLong, (function (status) {
                          var init = state.fieldsStatuses;
                          return {
                                  isStaking: init.isStaking,
                                  isLong: status,
                                  amount: init.amount
                                };
                        }));
                  if (result$1 !== undefined) {
                    return {
                            TAG: 0,
                            _0: {
                              input: state.input,
                              fieldsStatuses: result$1,
                              collectionsStatuses: state.collectionsStatuses,
                              formStatus: state.formStatus,
                              submissionStatus: state.submissionStatus
                            },
                            [Symbol.for("name")]: "Update"
                          };
                  } else {
                    return /* NoUpdate */0;
                  }
              case /* BlurAmountField */2 :
                  var result$2 = Formality.validateFieldOnBlurWithValidator(state.input, state.fieldsStatuses.amount, validators_amount, (function (status) {
                          var init = state.fieldsStatuses;
                          return {
                                  isStaking: init.isStaking,
                                  isLong: init.isLong,
                                  amount: status
                                };
                        }));
                  if (result$2 !== undefined) {
                    return {
                            TAG: 0,
                            _0: {
                              input: state.input,
                              fieldsStatuses: result$2,
                              collectionsStatuses: state.collectionsStatuses,
                              formStatus: state.formStatus,
                              submissionStatus: state.submissionStatus
                            },
                            [Symbol.for("name")]: "Update"
                          };
                  } else {
                    return /* NoUpdate */0;
                  }
              case /* Submit */3 :
                  var match = state.formStatus;
                  if (typeof match !== "number" && match.TAG === /* Submitting */0) {
                    return /* NoUpdate */0;
                  }
                  var match$1 = validateForm(state.input, validators, state.fieldsStatuses);
                  if (match$1.TAG !== /* Valid */0) {
                    return {
                            TAG: 0,
                            _0: {
                              input: state.input,
                              fieldsStatuses: match$1.fieldsStatuses,
                              collectionsStatuses: match$1.collectionsStatuses,
                              formStatus: /* Editing */0,
                              submissionStatus: /* AttemptedToSubmit */1
                            },
                            [Symbol.for("name")]: "Update"
                          };
                  }
                  var output = match$1.output;
                  var error = state.formStatus;
                  var tmp;
                  tmp = typeof error === "number" || error.TAG !== /* SubmissionFailed */1 ? undefined : Caml_option.some(error._0);
                  return {
                          TAG: 1,
                          _0: {
                            input: state.input,
                            fieldsStatuses: match$1.fieldsStatuses,
                            collectionsStatuses: match$1.collectionsStatuses,
                            formStatus: {
                              TAG: 0,
                              _0: tmp,
                              [Symbol.for("name")]: "Submitting"
                            },
                            submissionStatus: /* AttemptedToSubmit */1
                          },
                          _1: (function (param) {
                              var dispatch = param.dispatch;
                              return Curry._2(onSubmit, output, {
                                          notifyOnSuccess: (function (input) {
                                              return Curry._1(dispatch, {
                                                          TAG: 3,
                                                          _0: input,
                                                          [Symbol.for("name")]: "SetSubmittedStatus"
                                                        });
                                            }),
                                          notifyOnFailure: (function (error) {
                                              return Curry._1(dispatch, {
                                                          TAG: 4,
                                                          _0: error,
                                                          [Symbol.for("name")]: "SetSubmissionFailedStatus"
                                                        });
                                            }),
                                          reset: (function (param) {
                                              return Curry._1(dispatch, /* Reset */6);
                                            }),
                                          dismissSubmissionResult: (function (param) {
                                              return Curry._1(dispatch, /* DismissSubmissionResult */5);
                                            })
                                        });
                            }),
                          [Symbol.for("name")]: "UpdateWithSideEffects"
                        };
                  break;
              case /* DismissSubmissionError */4 :
                  var match$2 = state.formStatus;
                  if (typeof match$2 === "number" || match$2.TAG !== /* SubmissionFailed */1) {
                    return /* NoUpdate */0;
                  } else {
                    return {
                            TAG: 0,
                            _0: {
                              input: state.input,
                              fieldsStatuses: state.fieldsStatuses,
                              collectionsStatuses: state.collectionsStatuses,
                              formStatus: /* Editing */0,
                              submissionStatus: state.submissionStatus
                            },
                            [Symbol.for("name")]: "Update"
                          };
                  }
              case /* DismissSubmissionResult */5 :
                  var match$3 = state.formStatus;
                  if (typeof match$3 === "number") {
                    if (match$3 === /* Editing */0) {
                      return /* NoUpdate */0;
                    }
                    
                  } else if (match$3.TAG === /* Submitting */0) {
                    return /* NoUpdate */0;
                  }
                  return {
                          TAG: 0,
                          _0: {
                            input: state.input,
                            fieldsStatuses: state.fieldsStatuses,
                            collectionsStatuses: state.collectionsStatuses,
                            formStatus: /* Editing */0,
                            submissionStatus: state.submissionStatus
                          },
                          [Symbol.for("name")]: "Update"
                        };
              case /* Reset */6 :
                  return {
                          TAG: 0,
                          _0: initialState(initialInput),
                          [Symbol.for("name")]: "Update"
                        };
              
            }
          } else {
            switch (action.TAG | 0) {
              case /* UpdateIsStakingField */0 :
                  var nextInput = Curry._1(action._0, state.input);
                  return {
                          TAG: 0,
                          _0: {
                            input: nextInput,
                            fieldsStatuses: Formality.validateFieldOnChangeWithoutValidator(nextInput.isStaking, (function (status) {
                                    var init = state.fieldsStatuses;
                                    return {
                                            isStaking: status,
                                            isLong: init.isLong,
                                            amount: init.amount
                                          };
                                  })),
                            collectionsStatuses: state.collectionsStatuses,
                            formStatus: state.formStatus,
                            submissionStatus: state.submissionStatus
                          },
                          [Symbol.for("name")]: "Update"
                        };
              case /* UpdateIsLongField */1 :
                  var nextInput$1 = Curry._1(action._0, state.input);
                  return {
                          TAG: 0,
                          _0: {
                            input: nextInput$1,
                            fieldsStatuses: Formality.validateFieldOnChangeWithValidator(nextInput$1, state.fieldsStatuses.isLong, state.submissionStatus, validators_isLong, (function (status) {
                                    var init = state.fieldsStatuses;
                                    return {
                                            isStaking: init.isStaking,
                                            isLong: status,
                                            amount: init.amount
                                          };
                                  })),
                            collectionsStatuses: state.collectionsStatuses,
                            formStatus: state.formStatus,
                            submissionStatus: state.submissionStatus
                          },
                          [Symbol.for("name")]: "Update"
                        };
              case /* UpdateAmountField */2 :
                  var nextInput$2 = Curry._1(action._0, state.input);
                  return {
                          TAG: 0,
                          _0: {
                            input: nextInput$2,
                            fieldsStatuses: Formality.validateFieldOnChangeWithValidator(nextInput$2, state.fieldsStatuses.amount, state.submissionStatus, validators_amount, (function (status) {
                                    var init = state.fieldsStatuses;
                                    return {
                                            isStaking: init.isStaking,
                                            isLong: init.isLong,
                                            amount: status
                                          };
                                  })),
                            collectionsStatuses: state.collectionsStatuses,
                            formStatus: state.formStatus,
                            submissionStatus: state.submissionStatus
                          },
                          [Symbol.for("name")]: "Update"
                        };
              case /* SetSubmittedStatus */3 :
                  var input = action._0;
                  if (input !== undefined) {
                    return {
                            TAG: 0,
                            _0: {
                              input: input,
                              fieldsStatuses: {
                                isStaking: /* Pristine */0,
                                isLong: /* Pristine */0,
                                amount: /* Pristine */0
                              },
                              collectionsStatuses: state.collectionsStatuses,
                              formStatus: /* Submitted */1,
                              submissionStatus: state.submissionStatus
                            },
                            [Symbol.for("name")]: "Update"
                          };
                  } else {
                    return {
                            TAG: 0,
                            _0: {
                              input: state.input,
                              fieldsStatuses: {
                                isStaking: /* Pristine */0,
                                isLong: /* Pristine */0,
                                amount: /* Pristine */0
                              },
                              collectionsStatuses: state.collectionsStatuses,
                              formStatus: /* Submitted */1,
                              submissionStatus: state.submissionStatus
                            },
                            [Symbol.for("name")]: "Update"
                          };
                  }
              case /* SetSubmissionFailedStatus */4 :
                  return {
                          TAG: 0,
                          _0: {
                            input: state.input,
                            fieldsStatuses: state.fieldsStatuses,
                            collectionsStatuses: state.collectionsStatuses,
                            formStatus: {
                              TAG: 1,
                              _0: action._0,
                              [Symbol.for("name")]: "SubmissionFailed"
                            },
                            submissionStatus: state.submissionStatus
                          },
                          [Symbol.for("name")]: "Update"
                        };
              case /* MapSubmissionError */5 :
                  var map = action._0;
                  var error$1 = state.formStatus;
                  if (typeof error$1 === "number") {
                    return /* NoUpdate */0;
                  }
                  if (error$1.TAG !== /* Submitting */0) {
                    return {
                            TAG: 0,
                            _0: {
                              input: state.input,
                              fieldsStatuses: state.fieldsStatuses,
                              collectionsStatuses: state.collectionsStatuses,
                              formStatus: {
                                TAG: 1,
                                _0: Curry._1(map, error$1._0),
                                [Symbol.for("name")]: "SubmissionFailed"
                              },
                              submissionStatus: state.submissionStatus
                            },
                            [Symbol.for("name")]: "Update"
                          };
                  }
                  var error$2 = error$1._0;
                  if (error$2 !== undefined) {
                    return {
                            TAG: 0,
                            _0: {
                              input: state.input,
                              fieldsStatuses: state.fieldsStatuses,
                              collectionsStatuses: state.collectionsStatuses,
                              formStatus: {
                                TAG: 0,
                                _0: Caml_option.some(Curry._1(map, Caml_option.valFromOption(error$2))),
                                [Symbol.for("name")]: "Submitting"
                              },
                              submissionStatus: state.submissionStatus
                            },
                            [Symbol.for("name")]: "Update"
                          };
                  } else {
                    return /* NoUpdate */0;
                  }
              
            }
          }
        }));
  var dispatch = match[1];
  var state = match[0];
  var match$1 = state.formStatus;
  var tmp;
  tmp = typeof match$1 === "number" || match$1.TAG !== /* Submitting */0 ? false : true;
  return {
          updateIsStaking: (function (nextInputFn, nextValue) {
              return Curry._1(dispatch, {
                          TAG: 0,
                          _0: (function (__x) {
                              return Curry._2(nextInputFn, __x, nextValue);
                            }),
                          [Symbol.for("name")]: "UpdateIsStakingField"
                        });
            }),
          updateIsLong: (function (nextInputFn, nextValue) {
              return Curry._1(dispatch, {
                          TAG: 1,
                          _0: (function (__x) {
                              return Curry._2(nextInputFn, __x, nextValue);
                            }),
                          [Symbol.for("name")]: "UpdateIsLongField"
                        });
            }),
          updateAmount: (function (nextInputFn, nextValue) {
              return Curry._1(dispatch, {
                          TAG: 2,
                          _0: (function (__x) {
                              return Curry._2(nextInputFn, __x, nextValue);
                            }),
                          [Symbol.for("name")]: "UpdateAmountField"
                        });
            }),
          blurIsStaking: (function (param) {
              return Curry._1(dispatch, /* BlurIsStakingField */0);
            }),
          blurIsLong: (function (param) {
              return Curry._1(dispatch, /* BlurIsLongField */1);
            }),
          blurAmount: (function (param) {
              return Curry._1(dispatch, /* BlurAmountField */2);
            }),
          isStakingResult: Formality.exposeFieldResult(state.fieldsStatuses.isStaking),
          isLongResult: Formality.exposeFieldResult(state.fieldsStatuses.isLong),
          amountResult: Formality.exposeFieldResult(state.fieldsStatuses.amount),
          input: state.input,
          status: state.formStatus,
          dirty: (function (param) {
              var match = state.fieldsStatuses;
              if (match.isStaking || match.isLong || match.amount) {
                return true;
              } else {
                return false;
              }
            }),
          valid: (function (param) {
              var match = validateForm(state.input, validators, state.fieldsStatuses);
              if (match.TAG === /* Valid */0) {
                return true;
              } else {
                return false;
              }
            }),
          submitting: tmp,
          submit: (function (param) {
              return Curry._1(dispatch, /* Submit */3);
            }),
          dismissSubmissionError: (function (param) {
              return Curry._1(dispatch, /* DismissSubmissionError */4);
            }),
          dismissSubmissionResult: (function (param) {
              return Curry._1(dispatch, /* DismissSubmissionResult */5);
            }),
          mapSubmissionError: (function (map) {
              return Curry._1(dispatch, {
                          TAG: 5,
                          _0: map,
                          [Symbol.for("name")]: "MapSubmissionError"
                        });
            }),
          reset: (function (param) {
              return Curry._1(dispatch, /* Reset */6);
            })
        };
}

var MintForm = {
  validators: validators,
  initialFieldsStatuses: initialFieldsStatuses,
  initialCollectionsStatuses: undefined,
  initialState: initialState,
  validateForm: validateForm,
  useForm: useForm
};

function useBalanceAndApproved(erc20Address, spender) {
  var match = ContractHooks.useErc20BalanceRefresh(erc20Address);
  var match$1 = ContractHooks.useERC20ApprovedRefresh(erc20Address, spender);
  return [
          match.data,
          match$1.data
        ];
}

function isGreaterThanApproval(amount, amountApproved) {
  return amount.gt(amountApproved);
}

function isGreaterThanBalance(amount, balance) {
  return amount.gt(balance);
}

function MintForm$1(Props) {
  var market = Props.market;
  var initialIsLong = Props.initialIsLong;
  var signer = ContractActions.useSignerExn(undefined);
  var user = RootProvider.useCurrentUserExn(undefined);
  var match = ContractActions.useContractFunction(signer);
  var setTxState = match[2];
  var txState = match[1];
  var contractExecutionHandler = match[0];
  var match$1 = ContractActions.useContractFunction(signer);
  var setTxStateApprove = match$1[2];
  var txStateApprove = match$1[1];
  var contractExecutionHandlerApprove = match$1[0];
  var match$2 = React.useState(function () {
        return function (param) {
          
        };
      });
  var setContractActionToCallAfterApproval = match$2[1];
  var contractActionToCallAfterApproval = match$2[0];
  var longShortContractAddress = Config.useLongShortAddress(undefined);
  var daiAddressThatIsTemporarilyHardCoded = Config.useDaiAddress(undefined);
  var match$3 = useBalanceAndApproved(daiAddressThatIsTemporarilyHardCoded, longShortContractAddress);
  var optDaiAmountApproved = match$3[1];
  var optDaiBalance = match$3[0];
  var longBalanceQuery = Curry.app(Queries.UsersBalance.use, [
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        {
          userId: Globals.ethAdrToLowerStr(user),
          tokenAdr: Globals.ethAdrToLowerStr(market.syntheticLong.tokenAddress)
        }
      ]);
  var shortBalanceQuery = Curry.app(Queries.UsersBalance.use, [
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        {
          userId: Globals.ethAdrToLowerStr(user),
          tokenAdr: Globals.ethAdrToLowerStr(market.syntheticShort.tokenAddress)
        }
      ]);
  var form = useForm({
        amount: "",
        isLong: initialIsLong,
        isStaking: true
      }, (function (param, _form) {
          var isStaking = param.isStaking;
          var isLong = param.isLong;
          var amount = param.amount;
          var mintFunction = function (param) {
            var tmp;
            if (isLong) {
              var arg = market.marketIndex;
              tmp = (function (param) {
                  return param.mintLong(arg, amount);
                });
            } else {
              var arg$1 = market.marketIndex;
              tmp = (function (param) {
                  return param.mintShort(arg$1, amount);
                });
            }
            return Curry._2(contractExecutionHandler, (function (param) {
                          return Contracts.LongShort.make(longShortContractAddress, param);
                        }), tmp);
          };
          var mintAndStakeFunction = function (param) {
            var tmp;
            if (isLong) {
              var arg = market.marketIndex;
              tmp = (function (param) {
                  return param.mintLongAndStake(arg, amount);
                });
            } else {
              var arg$1 = market.marketIndex;
              tmp = (function (param) {
                  return param.mintShortAndStake(arg$1, amount);
                });
            }
            return Curry._2(contractExecutionHandler, (function (param) {
                          return Contracts.LongShort.make(longShortContractAddress, param);
                        }), tmp);
          };
          var needsToApprove = amount.gt(Belt_Option.getWithDefault(optDaiAmountApproved, Ethers$1.BigNumber.from("0")));
          if (needsToApprove) {
            Curry._1(setContractActionToCallAfterApproval, (function (param) {
                    if (isStaking) {
                      return mintAndStakeFunction;
                    } else {
                      return mintFunction;
                    }
                  }));
            var arg = amount.mul(Ethers$1.BigNumber.from("2"));
            return Curry._2(contractExecutionHandlerApprove, (function (param) {
                          return Contracts.Erc20.make(daiAddressThatIsTemporarilyHardCoded, param);
                        }), (function (param) {
                          return param.approve(longShortContractAddress, arg);
                        }));
          } else if (isStaking) {
            return mintAndStakeFunction(undefined);
          } else {
            return mintFunction(undefined);
          }
        }));
  var match$4 = form.amountResult;
  var formAmount = match$4 !== undefined && match$4.TAG === /* Ok */0 ? Caml_option.some(match$4._0) : undefined;
  var tokenToMint = form.input.isLong ? "long " + market.name : "short " + market.name;
  var stakingText = form.input.isStaking ? "Mint & Stake" : "Mint";
  var approveConnector = form.input.isStaking ? "," : " &";
  var isLong = form.input.isLong;
  var position = isLong ? "long" : "short";
  var match$5;
  var exit = 0;
  if (formAmount !== undefined && optDaiBalance !== undefined && optDaiAmountApproved !== undefined) {
    var amount = Caml_option.valFromOption(formAmount);
    var needsToApprove = amount.gt(Caml_option.valFromOption(optDaiAmountApproved));
    var greaterThanBalance = amount.gt(Caml_option.valFromOption(optDaiBalance));
    match$5 = greaterThanBalance ? [
        "Amount is greater than your balance",
        "Insufficient balance",
        true
      ] : [
        undefined,
        needsToApprove ? "Approve" + approveConnector + " " + stakingText + " " + position + " position" : stakingText + " " + position + " position",
        false
      ];
  } else {
    exit = 1;
  }
  if (exit === 1) {
    match$5 = [
      undefined,
      stakingText + " " + position + " position",
      true
    ];
  }
  var optAdditionalErrorMessage = match$5[0];
  React.useEffect((function () {
          if (typeof txStateApprove !== "number" && txStateApprove.TAG === /* Complete */2) {
            Curry._1(contractActionToCallAfterApproval, undefined);
            Curry._1(setTxStateApprove, (function (param) {
                    return /* UnInitialised */0;
                  }));
          }
          
        }), [txStateApprove]);
  var match$6 = form.amountResult;
  var tmp;
  var exit$1 = 0;
  var message;
  if (match$6 !== undefined) {
    if (match$6.TAG === /* Ok */0) {
      if (optAdditionalErrorMessage !== undefined) {
        message = optAdditionalErrorMessage;
        exit$1 = 1;
      } else {
        tmp = null;
      }
    } else {
      message = match$6._0;
      exit$1 = 1;
    }
  } else if (optAdditionalErrorMessage !== undefined) {
    message = optAdditionalErrorMessage;
    exit$1 = 1;
  } else {
    tmp = null;
  }
  if (exit$1 === 1) {
    tmp = React.createElement("div", {
          className: "text-red-500 text-xs"
        }, message);
  }
  var tmp$1;
  var exit$2 = 0;
  if (typeof txStateApprove === "number") {
    switch (txStateApprove) {
      case /* UnInitialised */0 :
          exit$2 = 1;
          break;
      case /* Created */1 :
          tmp$1 = React.createElement(React.Fragment, undefined, React.createElement("h1", undefined, "Please Approve that Float can use your " + Config.paymentTokenName));
          break;
      case /* Failed */2 :
          tmp$1 = React.createElement(React.Fragment, undefined, React.createElement("h1", undefined, "The transaction failed."), React.createElement("p", undefined, React.createElement("a", {
                        href: Config.discordInviteLink,
                        target: "_"
                      }, "This shouldn't happen, please let us help you on discord.")));
          break;
      
    }
  } else {
    switch (txStateApprove.TAG | 0) {
      case /* SignedAndSubmitted */0 :
          tmp$1 = React.createElement("h1", undefined, React.createElement("a", {
                    href: Config.defaultBlockExplorer + "tx/" + txStateApprove._0,
                    target: "_"
                  }, "Processing Approval "));
          break;
      case /* Declined */1 :
          tmp$1 = React.createElement(React.Fragment, undefined, React.createElement("h1", undefined, "The transaction was declined by your wallet, you need to accept the transaction to proceed."), React.createElement("p", undefined, "Failure reason: " + txStateApprove._0));
          break;
      case /* Complete */2 :
          var transactionHash = txStateApprove._0.transactionHash;
          var exit$3 = 0;
          if (typeof txState === "number") {
            switch (txState) {
              case /* UnInitialised */0 :
              case /* Created */1 :
                  exit$3 = 2;
                  break;
              default:
                exit$2 = 1;
            }
          } else if (txState.TAG === /* SignedAndSubmitted */0) {
            tmp$1 = React.createElement(React.Fragment, undefined, React.createElement("h1", undefined, React.createElement("a", {
                          href: Config.defaultBlockExplorer + "tx/" + transactionHash,
                          target: "_"
                        }, "✅ Approval Complete")), React.createElement("h1", undefined, React.createElement("a", {
                          href: Config.defaultBlockExplorer + "tx/" + txState._0,
                          target: "_"
                        }, "Processing minting " + tokenToMint + " with your " + Config.paymentTokenName)));
          } else {
            exit$2 = 1;
          }
          if (exit$3 === 2) {
            tmp$1 = React.createElement(React.Fragment, undefined, React.createElement("h1", undefined, React.createElement("a", {
                          href: Config.defaultBlockExplorer + "tx/" + transactionHash,
                          target: "_"
                        }, "✅ Approval Complete")), React.createElement("h1", undefined, "Sign the next transaction to mint your"));
          }
          break;
      
    }
  }
  if (exit$2 === 1) {
    if (typeof txState === "number") {
      switch (txState) {
        case /* UnInitialised */0 :
            tmp$1 = React.createElement(Button.make, {
                  onClick: (function (param) {
                      
                    }),
                  children: match$5[1],
                  variant: "large"
                });
            break;
        case /* Created */1 :
            tmp$1 = React.createElement(React.Fragment, undefined, React.createElement("h1", undefined, "Sign the transaction to mint " + tokenToMint + " with your " + Config.paymentTokenName));
            break;
        case /* Failed */2 :
            tmp$1 = React.createElement(React.Fragment, undefined, React.createElement("h1", undefined, "The transaction failed."), React.createElement("p", undefined, React.createElement("a", {
                          href: Config.discordInviteLink,
                          target: "_"
                        }, "This shouldn't happen, please let us help you on discord.")));
            break;
        
      }
    } else {
      switch (txState.TAG | 0) {
        case /* SignedAndSubmitted */0 :
            tmp$1 = React.createElement(React.Fragment, undefined, React.createElement("h1", undefined, React.createElement("a", {
                          href: Config.defaultBlockExplorer + "tx/" + txState._0,
                          target: "_"
                        }, "Processing minting " + tokenToMint + " with your " + Config.paymentTokenName)));
            break;
        case /* Declined */1 :
            tmp$1 = React.createElement(React.Fragment, undefined, React.createElement("h1", undefined, "The transaction was declined by your wallet, you need to accept the transaction to proceed."), React.createElement("p", undefined, "Failure reason: " + txState._0));
            break;
        case /* Complete */2 :
            tmp$1 = React.createElement(React.Fragment, undefined, React.createElement("h1", undefined, React.createElement("a", {
                          href: Config.defaultBlockExplorer + "tx/" + txState._0.transactionHash,
                          target: "_"
                        }, "✅ Transaction Complete")), React.createElement("h1", undefined));
            break;
        
      }
    }
  }
  var tmp$2;
  if (Config.isDevMode) {
    var txExplererUrl = RootProvider.useEtherscanUrl(undefined);
    var resetTxButton = React.createElement("button", {
          onClick: (function (param) {
              return Curry._1(setTxState, (function (param) {
                            return /* UnInitialised */0;
                          }));
            })
        }, ">>Reset tx<<");
    var tmp$3;
    if (typeof txState === "number") {
      switch (txState) {
        case /* UnInitialised */0 :
            tmp$3 = null;
            break;
        case /* Created */1 :
            tmp$3 = React.createElement(React.Fragment, undefined, React.createElement("h1", undefined, "Processing Transaction "), React.createElement("p", undefined, "Tx created."), React.createElement("div", undefined));
            break;
        case /* Failed */2 :
            tmp$3 = React.createElement(React.Fragment, undefined, React.createElement("h1", undefined, "The transaction failed."), React.createElement("p", undefined, "This operation isn't permitted by the smart contract."), resetTxButton);
            break;
        
      }
    } else {
      switch (txState.TAG | 0) {
        case /* SignedAndSubmitted */0 :
            tmp$3 = React.createElement(React.Fragment, undefined, React.createElement("h1", undefined, "Processing Transaction "), React.createElement("p", undefined, React.createElement("a", {
                          href: "https://" + txExplererUrl + "/tx/" + txState._0,
                          rel: "noopener noreferrer",
                          target: "_blank"
                        }, "View the transaction on " + txExplererUrl)));
            break;
        case /* Declined */1 :
            tmp$3 = React.createElement(React.Fragment, undefined, React.createElement("h1", undefined, "The transaction was declined by your wallet, please try again."), React.createElement("p", undefined, "Failure reason: " + txState._0), resetTxButton);
            break;
        case /* Complete */2 :
            var txHash = txState._0.transactionHash;
            tmp$3 = React.createElement(React.Fragment, undefined, React.createElement("h1", undefined, "Transaction Complete "), React.createElement("p", undefined, React.createElement("a", {
                          href: "https://" + txExplererUrl + "/tx/" + txHash,
                          rel: "noopener noreferrer",
                          target: "_blank"
                        }, "View the transaction on " + txExplererUrl)), resetTxButton);
            break;
        
      }
    }
    var formatOptBalance = function (__x) {
      return Belt_Option.mapWithDefault(__x, "Loading", Ethers.Utils.formatEther);
    };
    var match$7 = longBalanceQuery.data;
    var tmp$4;
    var exit$4 = 0;
    if (match$7 !== undefined) {
      var match$8 = match$7.user;
      if (match$8 !== undefined) {
        var match$9 = match$8.tokenBalances;
        if (match$9 !== undefined && match$9.length === 1) {
          var match$10 = match$9[0];
          tmp$4 = React.createElement("p", undefined, "long - balance: " + Ethers.Utils.formatEther(match$10.tokenBalance));
        } else {
          exit$4 = 1;
        }
      } else {
        exit$4 = 1;
      }
    } else {
      exit$4 = 1;
    }
    if (exit$4 === 1) {
      tmp$4 = React.createElement("p", undefined, "loading LONG balance");
    }
    var match$11 = shortBalanceQuery.data;
    var tmp$5;
    var exit$5 = 0;
    if (match$11 !== undefined) {
      var match$12 = match$11.user;
      if (match$12 !== undefined) {
        var match$13 = match$12.tokenBalances;
        if (match$13 !== undefined && match$13.length === 1) {
          var match$14 = match$13[0];
          tmp$5 = React.createElement("p", undefined, "short - balance: " + Ethers.Utils.formatEther(match$14.tokenBalance));
        } else {
          exit$5 = 1;
        }
      } else {
        exit$5 = 1;
      }
    } else {
      exit$5 = 1;
    }
    if (exit$5 === 1) {
      tmp$5 = React.createElement("p", undefined, "loading SHORT balance");
    }
    tmp$2 = React.createElement(React.Fragment, undefined, tmp$3, React.createElement("code", undefined, React.createElement("p", undefined, "dev only component to display balances"), React.createElement("p", undefined, "dai - balance: " + formatOptBalance(optDaiBalance) + " - approved: " + formatOptBalance(optDaiAmountApproved)), tmp$4, tmp$5));
  } else {
    tmp$2 = null;
  }
  return React.createElement("div", {
              className: "screen-centered-container"
            }, React.createElement(ViewBox.make, {
                  children: React.createElement(Form.make, {
                        className: "this-is-required",
                        onSubmit: (function (param) {
                            return Curry._1(form.submit, undefined);
                          }),
                        children: null
                      }, React.createElement("div", {
                            className: "flex justify-between mb-2"
                          }, React.createElement("h2", undefined, market.name + " (" + market.symbol + ")")), React.createElement("select", {
                            className: "trade-select",
                            disabled: form.submitting,
                            name: "longshort",
                            value: form.input.isLong ? "long" : "short",
                            onBlur: (function (param) {
                                return Curry._1(form.blurAmount, undefined);
                              }),
                            onChange: (function ($$event) {
                                return Curry._2(form.updateIsLong, (function (input, isLong) {
                                              return {
                                                      amount: input.amount,
                                                      isLong: isLong,
                                                      isStaking: input.isStaking
                                                    };
                                            }), $$event.target.value === "long");
                              })
                          }, React.createElement("option", {
                                value: "long"
                              }, "Long 🐮"), React.createElement("option", {
                                value: "short"
                              }, "Short 🐻")), React.createElement(AmountInput.make, {
                            placeholder: "Mint",
                            value: form.input.amount,
                            optBalance: optDaiBalance,
                            disabled: form.submitting,
                            onBlur: (function (param) {
                                return Curry._1(form.blurAmount, undefined);
                              }),
                            onChange: (function ($$event) {
                                return Curry._2(form.updateAmount, (function (input, amount) {
                                              return {
                                                      amount: amount,
                                                      isLong: input.isLong,
                                                      isStaking: input.isStaking
                                                    };
                                            }), $$event.target.value);
                              }),
                            onMaxClick: (function (param) {
                                return Curry._2(form.updateAmount, (function (input, amount) {
                                              return {
                                                      amount: amount,
                                                      isLong: input.isLong,
                                                      isStaking: input.isStaking
                                                    };
                                            }), optDaiBalance !== undefined ? Ethers.Utils.formatEther(Caml_option.valFromOption(optDaiBalance)) : "0");
                              })
                          }), tmp, React.createElement("div", {
                            className: "flex justify-between items-center"
                          }, React.createElement("div", {
                                className: "flex items-center"
                              }, React.createElement("input", {
                                    className: "mr-2",
                                    id: "stake-checkbox",
                                    checked: form.input.isStaking,
                                    disabled: form.submitting,
                                    type: "checkbox",
                                    onBlur: (function (param) {
                                        return Curry._1(form.blurIsStaking, undefined);
                                      }),
                                    onChange: (function ($$event) {
                                        return Curry._2(form.updateIsStaking, (function (input, value) {
                                                      return {
                                                              amount: input.amount,
                                                              isLong: input.isLong,
                                                              isStaking: value
                                                            };
                                                    }), $$event.target.checked);
                                      })
                                  }), React.createElement("label", {
                                    className: "text-xs",
                                    htmlFor: "stake-checkbox"
                                  }, "Stake " + (
                                    form.input.isLong ? "long" : "short"
                                  ) + " tokens")), React.createElement("p", {
                                className: "text-xxs hover:text-gray-500"
                              }, React.createElement("a", {
                                    href: "https://docs.float.capital/docs/stake"
                                  }, "Learn more about staking"))), tmp$1)
                }), tmp$2);
}

var initialInput = {
  amount: "",
  isLong: false,
  isStaking: true
};

var make = MintForm$1;

export {
  MintForm ,
  initialInput ,
  useBalanceAndApproved ,
  isGreaterThanApproval ,
  isGreaterThanBalance ,
  make ,
  
}
/* Form Not a pure module */
