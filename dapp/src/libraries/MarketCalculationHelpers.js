// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Ethers = require("../ethereum/Ethers.js");
var Ethers$1 = require("ethers");
var Globals = require("./Globals.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var CONSTANTS = require("../CONSTANTS.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Belt_HashMapString = require("rescript/lib/js/belt_HashMapString.js");

function calculateBeta(totalValueLocked, totalLockedLong, totalLockedShort, isLong) {
  if (totalValueLocked.eq(CONSTANTS.zeroBN) || totalLockedLong.eq(CONSTANTS.zeroBN) || totalLockedShort.eq(CONSTANTS.zeroBN)) {
    return "0";
  } else if (totalLockedLong.eq(totalLockedShort)) {
    return "100";
  } else if (isLong && totalLockedShort.lt(totalLockedLong)) {
    return Globals.percentStr(totalLockedShort, totalLockedLong);
  } else if (!isLong && totalLockedLong.lt(totalLockedShort)) {
    return Globals.percentStr(totalLockedLong, totalLockedShort);
  } else {
    return "100";
  }
}

function kCalc(kperiod, kmultiplier, initialTimestamp, currentTimestamp) {
  if (currentTimestamp.sub(initialTimestamp).lte(kperiod)) {
    return kmultiplier.sub(kmultiplier.sub(CONSTANTS.tenToThe18).mul(currentTimestamp.sub(initialTimestamp)).div(kperiod));
  } else {
    return CONSTANTS.tenToThe18;
  }
}

function xoredAssignment(condition, a, b) {
  var first = condition ? a : b;
  var second = condition ? b : a;
  return [
          first,
          second
        ];
}

function calcLongAndShortDollarFloatPerSecondUnscaled(longVal, shortVal, equibOffset, initialTimestamp, currentTimestamp, kperiod, kmultiplier, balanceIncentiveExponent) {
  var totalLocked = longVal.add(shortVal);
  var equibOffsetScaled = equibOffset.mul(totalLocked).div(CONSTANTS.tenToThe18).div(CONSTANTS.twoBN);
  var shortValAfterOffset = shortVal.sub(equibOffsetScaled);
  var longIsSideWithMoreValAfterOffset = shortValAfterOffset.sub(equibOffsetScaled).lt(longVal);
  var sideWithLessValAfterEquibOffset = longIsSideWithMoreValAfterOffset ? shortValAfterOffset : longVal.add(equibOffsetScaled);
  var rewardsForSideMoreValAfterOffset;
  if (sideWithLessValAfterEquibOffset.lte(CONSTANTS.zeroBN)) {
    rewardsForSideMoreValAfterOffset = CONSTANTS.zeroBN;
  } else {
    var numerator = sideWithLessValAfterEquibOffset.div(CONSTANTS.stakeDivisorForSafeExponentiationDiv2).pow(balanceIncentiveExponent);
    var denominator = totalLocked.div(CONSTANTS.stakeDivisorForSafeExponentiation).pow(balanceIncentiveExponent);
    rewardsForSideMoreValAfterOffset = numerator.mul(CONSTANTS.tenToThe18Div2).div(denominator);
  }
  var rewardsForSideWithLessValAfterOffset = CONSTANTS.tenToThe18.sub(rewardsForSideMoreValAfterOffset);
  var k = kCalc(kperiod, kmultiplier, initialTimestamp, currentTimestamp);
  return xoredAssignment(longIsSideWithMoreValAfterOffset, k.mul(rewardsForSideMoreValAfterOffset), k.mul(rewardsForSideWithLessValAfterOffset));
}

function calculateFloatAPY(longVal, shortVal, kperiod, kmultiplier, initialTimestamp, currentTimestamp, equibOffset, balanceIncentiveExponent, tokenType) {
  var match = calcLongAndShortDollarFloatPerSecondUnscaled(longVal, shortVal, equibOffset, initialTimestamp, currentTimestamp, kperiod, kmultiplier, balanceIncentiveExponent);
  if (tokenType === "long") {
    return match[0].mul(CONSTANTS.twoBN).div(CONSTANTS.tenToThe18);
  } else {
    return match[1].mul(CONSTANTS.twoBN).div(CONSTANTS.tenToThe18);
  }
}

function calculateFloatMintedOverPeriod(dollarFloatPerSecond, amount, period, price) {
  return dollarFloatPerSecond.mul(price).div(CONSTANTS.tenToThe18).mul(period).mul(amount).div(CONSTANTS.tenToThe42);
}

function calculateStakeAPYS(syntheticMarkets, $$global, apy) {
  var totalTreasuryYieldAfterYear = {
    contents: CONSTANTS.zeroBN
  };
  var totalFloatMintedAfterAYear = {
    contents: $$global.totalFloatMinted
  };
  var tokenFloatMintedAfterAYearDict = Belt_HashMapString.make(10);
  var tokenAPYDict = Belt_HashMapString.make(10);
  Belt_Array.forEach(syntheticMarkets, (function (market) {
          var match = market.latestSystemState;
          var totalValueLocked = match.totalValueLocked;
          var totalLockedShort = match.totalLockedShort;
          var totalLockedLong = match.totalLockedLong;
          var match$1 = market.syntheticShort;
          var match$2 = market.syntheticLong;
          var marketsShareOfYield = Caml_obj.caml_min(totalLockedLong.sub(totalLockedShort).abs().mul(CONSTANTS.yieldGradientHardcode).div(totalValueLocked), CONSTANTS.tenToThe18);
          totalTreasuryYieldAfterYear.contents = totalTreasuryYieldAfterYear.contents.add(CONSTANTS.tenToThe18.sub(marketsShareOfYield).mul(apy).mul(totalValueLocked).div(CONSTANTS.tenToThe18).div(CONSTANTS.tenToThe18));
          var match$3 = calcLongAndShortDollarFloatPerSecondUnscaled(totalLockedLong, totalLockedShort, CONSTANTS.equilibriumOffsetHardcode, market.timestampCreated, match.timestamp, CONSTANTS.kperiodHardcode, CONSTANTS.kmultiplierHardcode, CONSTANTS.balanceIncentiveExponentHardcode);
          var longFloatOverYear = calculateFloatMintedOverPeriod(match$3[0], match$2.totalStaked, Ethers$1.BigNumber.from(CONSTANTS.oneYearInSeconds), match$2.latestPrice.price.price);
          var shortFloatOverYear = calculateFloatMintedOverPeriod(match$3[1], match$1.totalStaked, Ethers$1.BigNumber.from(CONSTANTS.oneYearInSeconds), match$1.latestPrice.price.price);
          totalFloatMintedAfterAYear.contents = totalFloatMintedAfterAYear.contents.add(shortFloatOverYear).add(longFloatOverYear);
          Belt_HashMapString.set(tokenFloatMintedAfterAYearDict, match$2.id, longFloatOverYear);
          return Belt_HashMapString.set(tokenFloatMintedAfterAYearDict, match$1.id, shortFloatOverYear);
        }));
  totalFloatMintedAfterAYear.contents = totalFloatMintedAfterAYear.contents.mul(CONSTANTS.tenToThe18.add(CONSTANTS.floatCapitalPercentE18HardCode)).div(CONSTANTS.tenToThe18);
  var floatAfterYearToAPYE18 = function (floatAfterYear, totalStaked, price) {
    if (totalStaked.eq(CONSTANTS.zeroBN)) {
      return CONSTANTS.zeroBN;
    } else {
      return floatAfterYear.mul(CONSTANTS.tenToThe18).div(totalFloatMintedAfterAYear.contents).mul(totalTreasuryYieldAfterYear.contents).div(totalStaked.mul(price).div(CONSTANTS.tenToThe18));
    }
  };
  Belt_Array.forEach(syntheticMarkets, (function (market) {
          var match = market.syntheticShort;
          var shortId = match.id;
          var match$1 = market.syntheticLong;
          var longId = match$1.id;
          var longApy = floatAfterYearToAPYE18(Belt_HashMapString.get(tokenFloatMintedAfterAYearDict, longId), match$1.totalStaked, match$1.latestPrice.price.price);
          var shortApy = floatAfterYearToAPYE18(Belt_HashMapString.get(tokenFloatMintedAfterAYearDict, shortId), match.totalStaked, match.latestPrice.price.price);
          Belt_HashMapString.set(tokenAPYDict, longId, Number(Ethers.Utils.formatEther(longApy)));
          return Belt_HashMapString.set(tokenAPYDict, shortId, Number(Ethers.Utils.formatEther(shortApy)));
        }));
  return tokenAPYDict;
}

function calculateLendingProviderAPYForSide(collateralTokenApy, longVal, shortVal, tokenType) {
  switch (tokenType) {
    case "long" :
        if (longVal >= shortVal) {
          return 0.0;
        } else {
          return collateralTokenApy * (shortVal - longVal) / longVal;
        }
    case "short" :
        if (shortVal >= longVal) {
          return 0.0;
        } else {
          return collateralTokenApy * (longVal - shortVal) / shortVal;
        }
    default:
      return collateralTokenApy;
  }
}

function calculateLendingProviderAPYForSideMapped(apy, longVal, shortVal, tokenType) {
  if (typeof apy === "number" || apy.TAG !== /* Loaded */0) {
    return apy;
  } else {
    return {
            TAG: 0,
            _0: calculateLendingProviderAPYForSide(apy._0, longVal, shortVal, tokenType),
            [Symbol.for("name")]: "Loaded"
          };
  }
}

function mapStakeApy(apyDict, key) {
  if (typeof apyDict === "number") {
    return /* Loading */0;
  } else if (apyDict.TAG === /* Loaded */0) {
    return {
            TAG: 0,
            _0: Belt_Option.getExn(Belt_HashMapString.get(apyDict._0, key)),
            [Symbol.for("name")]: "Loaded"
          };
  } else {
    return {
            TAG: 1,
            _0: apyDict._0,
            [Symbol.for("name")]: "Error"
          };
  }
}

exports.calculateBeta = calculateBeta;
exports.kCalc = kCalc;
exports.xoredAssignment = xoredAssignment;
exports.calcLongAndShortDollarFloatPerSecondUnscaled = calcLongAndShortDollarFloatPerSecondUnscaled;
exports.calculateFloatAPY = calculateFloatAPY;
exports.calculateFloatMintedOverPeriod = calculateFloatMintedOverPeriod;
exports.calculateStakeAPYS = calculateStakeAPYS;
exports.calculateLendingProviderAPYForSide = calculateLendingProviderAPYForSide;
exports.calculateLendingProviderAPYForSideMapped = calculateLendingProviderAPYForSideMapped;
exports.mapStakeApy = mapStakeApy;
/* Ethers Not a pure module */
