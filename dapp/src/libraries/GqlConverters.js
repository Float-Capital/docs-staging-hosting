// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Ethers = require("../ethereum/Ethers.js");
var Ethers$1 = require("ethers");
var Globals = require("./Globals.js");
var Js_json = require("rescript/lib/js/js_json.js");
var CONSTANTS = require("../CONSTANTS.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var FromUnixTime = require("date-fns/fromUnixTime").default;

function jsonToBigInt(json) {
  var str = Js_json.decodeString(json);
  if (str !== undefined) {
    return Ethers$1.BigNumber.from(str);
  } else {
    console.log("CRITICAL - should never happen!");
    return Ethers$1.BigNumber.from("0");
  }
}

function serialize(bn) {
  return bn.toString();
}

var $$BigInt = {
  parse: jsonToBigInt,
  serialize: serialize
};

function parse(json) {
  var str = Js_json.decodeString(json);
  if (str !== undefined) {
    return str;
  } else {
    console.log("CRITICAL - should never happen!");
    return "couldn't decode bytes";
  }
}

function serialize$1(bytesString) {
  return bytesString;
}

var Bytes = {
  parse: parse,
  serialize: serialize$1
};

function parse$1(json) {
  var address = Belt_Option.flatMap(Js_json.decodeString(json), Ethers.Utils.getAddress);
  if (address !== undefined) {
    return Caml_option.valFromOption(address);
  } else {
    console.log("CRITICAL - couldn't decode eth address from graph, should never happen!");
    return CONSTANTS.zeroAddress;
  }
}

var serialize$2 = Globals.ethAdrToLowerStr;

var Address = {
  parse: parse$1,
  serialize: serialize$2
};

function parse$2(json) {
  return FromUnixTime(jsonToBigInt(json).toNumber());
}

function serialize$3(_jsDate) {
  return "not implemented";
}

var $$Date = {
  parse: parse$2,
  serialize: serialize$3
};

exports.jsonToBigInt = jsonToBigInt;
exports.$$BigInt = $$BigInt;
exports.Bytes = Bytes;
exports.Address = Address;
exports.$$Date = $$Date;
/* Ethers Not a pure module */
